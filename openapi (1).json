{
  "openapi": "3.1.0",
  "info": {
    "contact": {
      "email": "support@flussonic.com",
      "name": "Support team",
      "url": "https://flussonic.com/"
    },
    "description": "This document describes possible URLs that can be accessed by a player for playing video streams and files by various protocols.\n\nPermanent [download link](https://flussonic.com/doc/api/streaming.json) to JSON schema file.\n\nIt is worth noting that parameter `{name}` used in this schema may be multi-segment, i.e.: \n`/part1/part2/part3/index.m3u8` and `name` here will be `/part1/part2/part3`.\n\nAt the moment container format is selected automatically depending on source video codec. `fmp4` is used in\ncase of `hevc`, otherwise `ts` is used. \n\nIn the future perspective Flussonic is going to use `fmp4` container as default for all types of encoded video.\n\nTo keep using `ts` container please refer to `HLS TS playback` API section and consider to change your manifest\nurls.\n",
    "title": "Flussonic Streaming API",
    "version": "24.11-635"
  },
  "components": {
    "schemas": {
      "ts_pid": {
        "maximum": 8191,
        "minimum": 0,
        "type": "integer"
      },
      "auth_token": {
        "type": "string",
        "format": "auth_token",
        "default": "token",
        "example": "token",
        "description": "Configure key name of query string key-value pair for token authentication\n",
        "x-format-description": "auth_token"
      },
      "collection_response": {
        "type": "object",
        "properties": {
          "estimated_count": {
            "description": "Estimated total number of records for the query (regardless of the cursors).\n",
            "type": "integer",
            "example": 5
          },
          "next": {
            "description": "Next cursor: a properly encoded equivalent of offset allowing to read the next bunch of items.\nLearn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).\n",
            "example": "JTI0cG9zaXRpb25fZ3Q9MA==",
            "type": "string"
          },
          "prev": {
            "description": "Previous cursor: a properly encoded equivalent of offset allowing to read the previous bunch of items.\nLearn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).\n",
            "example": "JTI0cG9zaXRpb25fbHQ9MSYlMjRyZXZlcnNlZD10cnVl",
            "type": "string"
          },
          "timing": {
            "description": "An object with a list of different timings measured during this API call.",
            "type": "object"
          }
        }
      },
      "error_response": {
        "type": "object",
        "properties": {
          "errors": {
            "description": "List of structured errors",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/error"
            }
          }
        }
      },
      "error": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "a unique identifier for this particular occurrence of the problem\n"
          },
          "status": {
            "type": "string",
            "description": "the HTTP status code applicable to this problem, expressed as a string value\n"
          },
          "code": {
            "type": "string",
            "description": "an application-specific error code, expressed as a string value\n"
          },
          "title": {
            "type": "string",
            "description": "a short, human-readable summary of the problem that SHOULD NOT change from\noccurrence to occurrence of the problem, except for purposes of localization\n"
          },
          "source": {
            "description": "an object containing references to the source of the error\n",
            "type": "object",
            "properties": {
              "pointer": {
                "type": "string",
                "description": "a JSON Pointer [RFC6901] to the associated entity in the request document\n[e.g. `\"/data\"` for a primary data object, or `\"/data/attributes/title\"` for a specific attribute].\n"
              },
              "parameter": {
                "type": "string",
                "description": "a string indicating which URI query parameter caused the error."
              }
            }
          },
          "meta": {
            "type": "object",
            "description": "a meta object containing non-standard meta-information about the error.\n",
            "additionalProperties": {
              "type": "string"
            }
          }
        }
      },
      "frame_video_codec": {
        "type": "string",
        "oneOf": [
          {
            "title": "H.264",
            "const": "h264"
          },
          {
            "title": "HEVC (H.265)",
            "const": "hevc"
          },
          {
            "title": "MP2V",
            "const": "mp2v"
          },
          {
            "title": "VP9",
            "const": "vp9",
            "deprecated": true,
            "x-delete-at": 23.09
          },
          {
            "title": "MJPEG",
            "const": "mjpeg"
          },
          {
            "title": "Screen",
            "const": "screen"
          },
          {
            "title": "JPEG",
            "const": "jpeg"
          },
          {
            "title": "AV1",
            "const": "av1"
          },
          {
            "title": "JPEG 2000",
            "const": "j2k"
          }
        ]
      },
      "frame_audio_codec": {
        "type": "string",
        "oneOf": [
          {
            "title": "AAC",
            "const": "aac",
            "x-api-allow": [
              "watcher-client",
              "watcher-admin"
            ]
          },
          {
            "title": "MP3",
            "const": "mp3"
          },
          {
            "title": "MP2A",
            "const": "mp2a"
          },
          {
            "title": "Opus",
            "const": "opus"
          },
          {
            "title": "AC3",
            "const": "ac3"
          },
          {
            "title": "EAC3",
            "const": "eac3"
          },
          {
            "title": "PCMA",
            "const": "pcma"
          },
          {
            "title": "PCMU",
            "const": "pcmu"
          }
        ]
      },
      "frame_text_codec": {
        "type": "string",
        "oneOf": [
          {
            "title": "TTXT",
            "const": "ttxt"
          },
          {
            "title": "Text",
            "const": "text"
          },
          {
            "title": "WVTT",
            "const": "wvtt"
          },
          {
            "title": "TTML",
            "const": "ttml"
          },
          {
            "title": "Subtitle",
            "const": "subtitle"
          },
          {
            "title": "ID3T",
            "const": "id3t"
          },
          {
            "title": "ONVIF",
            "const": "onvif"
          },
          {
            "title": "TX3G",
            "const": "tx3g"
          }
        ]
      },
      "frame_raw_codec": {
        "type": "string",
        "oneOf": [
          {
            "title": "YUV",
            "const": "yuv"
          },
          {
            "title": "UYVY422",
            "const": "uyvy422"
          },
          {
            "title": "YUYV422",
            "const": "yuyv422"
          },
          {
            "title": "YUV422p10",
            "const": "yuv422p10"
          },
          {
            "title": "ARGB",
            "const": "argb"
          },
          {
            "title": "RGB48",
            "const": "rgb48"
          },
          {
            "title": "V210",
            "const": "v210"
          },
          {
            "title": "PCM",
            "const": "pcm"
          }
        ]
      },
      "frame_app_codec": {
        "oneOf": [
          {
            "title": "MPEG-TS",
            "const": "mpegts"
          },
          {
            "title": "Object",
            "const": "object"
          },
          {
            "title": "EIT",
            "const": "eit"
          },
          {
            "title": "SCTE-27",
            "const": "scte27"
          },
          {
            "title": "SCTE-35",
            "const": "scte35"
          },
          {
            "title": "KLV",
            "const": "klv"
          },
          {
            "title": "Empty",
            "const": "empty"
          }
        ],
        "type": "string"
      },
      "frame_codec": {
        "anyOf": [
          {
            "$ref": "#/components/schemas/frame_video_codec"
          },
          {
            "$ref": "#/components/schemas/frame_audio_codec"
          },
          {
            "$ref": "#/components/schemas/frame_raw_codec"
          },
          {
            "$ref": "#/components/schemas/frame_text_codec"
          },
          {
            "$ref": "#/components/schemas/frame_app_codec"
          }
        ]
      },
      "frame_content": {
        "type": "string",
        "oneOf": [
          {
            "title": "Audio",
            "const": "audio"
          },
          {
            "title": "Video",
            "const": "video"
          },
          {
            "title": "Text",
            "const": "text"
          },
          {
            "title": "Metadata",
            "const": "metadata"
          },
          {
            "title": "Application",
            "const": "application"
          }
        ]
      },
      "frame_video_pix_fmt": {
        "type": "string",
        "oneOf": [
          {
            "title": "YUV420P",
            "const": "yuv420p"
          },
          {
            "title": "YUVJ420P",
            "const": "yuvj420p"
          },
          {
            "title": "YUV422P",
            "const": "yuv422p"
          },
          {
            "title": "YUV444P",
            "const": "yuv444p"
          },
          {
            "title": "YUV420P10",
            "const": "yuv420p10"
          },
          {
            "title": "YUV422P10",
            "const": "yuv422p10"
          },
          {
            "title": "YUV444P10",
            "const": "yuv444p10"
          },
          {
            "title": "YUV420P12",
            "const": "yuv420p12"
          },
          {
            "title": "YUV422P12",
            "const": "yuv422p12"
          },
          {
            "title": "YUV444P12",
            "const": "yuv444p12"
          },
          {
            "title": "Gray8",
            "const": "gray8"
          },
          {
            "title": "Gray10",
            "const": "gray10"
          },
          {
            "title": "Gray12",
            "const": "gray12"
          },
          {
            "title": "NV12",
            "const": "nv12"
          },
          {
            "title": "P016",
            "const": "p016"
          },
          {
            "title": "V210",
            "const": "v210"
          },
          {
            "title": "UYVY422",
            "const": "uyvy422"
          },
          {
            "title": "YUYV422",
            "const": "yuyv422"
          },
          {
            "title": "RGB48",
            "const": "rgb48"
          },
          {
            "title": "ARGB",
            "const": "argb"
          }
        ]
      },
      "track_info": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/track_info_video"
          },
          {
            "$ref": "#/components/schemas/track_info_audio"
          },
          {
            "$ref": "#/components/schemas/track_info_text"
          },
          {
            "$ref": "#/components/schemas/track_info_metadata"
          },
          {
            "$ref": "#/components/schemas/track_info_application"
          }
        ],
        "discriminator": {
          "propertyName": "content",
          "mapping": {
            "video": "#/components/schemas/track_info_video",
            "audio": "#/components/schemas/track_info_audio",
            "text": "#/components/schemas/track_info_text",
            "metadata": "#/components/schemas/track_info_metadata",
            "application": "#/components/schemas/track_info_application"
          }
        },
        "x-record-definition": "#/components/schemas/track_info_full"
      },
      "track_info_base": {
        "type": "object",
        "properties": {
          "track_id": {
            "description": "Track identifier assigned by Flussonic.",
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "string"
              }
            ],
            "example": "v1"
          },
          "frame_duration": {
            "description": "For video track, it is the time between the beginning of a frame and the beginning of the next frame.\n\nThis parameter is important for some protocols. Normally, frame duration is a difference between timestamps of two neighbouring frames.\nHowever, sometimes (when the connection is broken) video breakups are possible.\nAs result, the delta between two consequent frame timestamps will not be equal to the frame duration.\nThis situation is considered as a frame gap and is handled differently across different protocols.\n",
            "type": "number",
            "format": "ticks",
            "x-format-description": "ticks"
          },
          "avg_fps": {
            "description": "Actual average FPS - the number of frames diplayed per second (calculated for the last 200 frames).\nThe higher FPS is, the smoother the video playback is. \nUsually, standard values of FPS for films and video are used in different countries (for example, in Russia and Europe it is 25 FPS).\n",
            "type": "number",
            "x-notice": "calculated fps for statistic"
          },
          "bandwidth": {
            "description": "Bandwidth necessary to transfer this track.\nThis is slightly grater than bitrate because transport (e.g. MPEG TS) adds some overhead\n",
            "type": "integer",
            "format": "speed",
            "example": 2600,
            "x-format-description": "speed"
          }
        }
      },
      "track_info_base_configurable": {
        "type": "object",
        "required": [
          "content"
        ],
        "properties": {
          "content": {
            "description": "Content of the track (audio, video, or text).",
            "allOf": [
              {
                "$ref": "#/components/schemas/frame_content"
              }
            ],
            "x-api-allow": [
              "smartcam",
              "iris-hal"
            ]
          },
          "title": {
            "description": "Human-readable localized title of the track.",
            "type": "string",
            "x-notice": "Human-readable localized title for HDS/HLS",
            "example": "Video1"
          },
          "bitrate": {
            "description": "Bitrate of the track in kbit/s.\nWhen using sdtv/hdtv/uhdtv transcoder target, for video tracks\nthis field sets the desired transport bandwidth instead of raw video bitrate.\n",
            "type": "integer",
            "format": "speed",
            "example": 2543,
            "x-api-allow": [
              "smartcam",
              "iris-hal"
            ],
            "x-format-description": "speed"
          },
          "pid": {
            "description": "This parameter sets PIDs values for outgoing MPEG-TS streams.\nPID identifies separate data stream inside the multiplexed MPEG-TS stream.\nIt is possible to set PID values for PMT, SDT, video, and audio tracks.\nTracks are numbered starting from one. The code a1=123 sets a PID value for the first audio track.\n\nIt is possible to set the base index for the tracks of a certain type using the 0 (zero) index.\nFor example, t0=100 sets PID=101 for the first track, 102 for the second, and so on.\nNumbers can be given in decimal form (by default) or hexadecimal with 16# prefix.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/ts_pid"
              }
            ]
          }
        }
      },
      "track_info_video": {
        "allOf": [
          {
            "$ref": "#/components/schemas/track_info_base"
          },
          {
            "$ref": "#/components/schemas/track_info_base_configurable"
          },
          {
            "type": "object",
            "properties": {
              "codec": {
                "description": "Codec of the track. Different codecs do **not** get the same track.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/frame_codec"
                  }
                ],
                "example": "h264",
                "x-api-allow": [
                  "smartcam",
                  "iris-hal"
                ]
              }
            }
          },
          {
            "$ref": "#/components/schemas/track_info_video_specific"
          },
          {
            "$ref": "#/components/schemas/track_info_video_configurable"
          }
        ]
      },
      "track_info_video_specific": {
        "type": "object",
        "properties": {
          "last_gop": {
            "description": "Last GOP size (expressed in number of frames).\nThis parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.\nIf this value is floating, this means that your transcoder is working in a flexible GOP size mode and some players may have problems.\nThis is not acceptable by most ABR usecases and it will not pass DVB validation protocol.\n",
            "type": "integer",
            "example": 28
          },
          "avg_gop": {
            "type": "integer",
            "description": "Average GOP size (expressed in number of frames) of the last 1000-2000 frames.\nThis parameter is used to monitor the quality of encoding: normally, average GOP size should be equal to the last GOP size.\nIf this value is floating, this means that your transcoder is working in flexible GOP size mode and some players may have problems.\nThis is not acceptable by most ABR usecases and it will not pass DVB validation protocol.\n",
            "example": 25
          },
          "length_size": {
            "enum": [
              2,
              4
            ],
            "default": 4,
            "type": "integer",
            "x-notice": "H264 private option",
            "description": "The size of the length field for H264 bitstream without start codes."
          },
          "is_progressive": {
            "description": "Indicates if progressive scanning method is used for all frames of the track\n",
            "type": "boolean",
            "default": true
          },
          "closed_captions": {
            "description": "Parameters of closed captions.",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/closed_captions"
                }
              ]
            },
            "type": "array",
            "default": []
          }
        }
      },
      "track_info_video_configurable": {
        "type": "object",
        "properties": {
          "width": {
            "description": "The picture width in pixels on the display where it will be played by a player.\nIf you need to insert a web-player into a web page, use this value for choosing the player size.\n",
            "type": "integer",
            "format": "pixels",
            "x-api-allow": [
              "smartcam"
            ],
            "x-format-description": "pixels"
          },
          "height": {
            "description": "The picture height in pixels on the display where it will be played by a player.\nIf you need to insert a web-player into a web page, use this value for choosing the player size.\n",
            "type": "integer",
            "format": "pixels",
            "x-api-allow": [
              "smartcam"
            ],
            "x-format-description": "pixels"
          },
          "fps": {
            "description": "Frame rate (frames per second) - the speed at which a sequence of images is displayed on a screen.\nHigher frame rates capture more images per second, which makes for smoother video.\nThe standard frame rate for color television in the Phase Alternating Line (PAL) format is 25 fps.\nThe standard frame rate for color television in the National Television System Committee (NTSC) format is 29,97 fps\n(a little bit lower than the original frame rate of black and white NTSC television, equal to 30 fps.)\nIf interlaced TV is used, two fields of each frame (with odd-numbered lines and with even-numbered lines) are displayed consequently,\nbut the frame rate is actually not doubled (50 half-frames are still equal to 25 original frames). \n",
            "type": "number",
            "x-api-allow": [
              "smartcam"
            ]
          },
          "pix_fmt": {
            "allOf": [
              {
                "$ref": "#/components/schemas/frame_video_pix_fmt"
              }
            ],
            "default": "yuv420p",
            "description": "The color model of the video."
          },
          "num_refs_frames": {
            "type": "integer",
            "maximum": 32,
            "minimum": 0,
            "description": "The number of I-frames to be used for encoding."
          },
          "sar_width": {
            "description": "The first number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.\nSAR is used for creating non-anamorphic video from anamorphic video.\n",
            "default": 1,
            "type": "integer",
            "externalDocs": {
              "description": "Find more information here",
              "url": "https://flussonic.com/doc/transcoder-internals/#transcoder-options_sar"
            }
          },
          "sar_height": {
            "description": "The second number in SAR. SAR is the ratio of the width of the display video representation to the width of the pixel representation.\nSAR is used for creating non-anamorphic video from anamorphic video.\n",
            "default": 1,
            "type": "integer",
            "externalDocs": {
              "description": "Find more information here",
              "url": "https://flussonic.com/doc/transcoder-internals/#transcoder-options_sar"
            }
          },
          "pixel_width": {
            "description": "The picture width in pixels of the original video before transcoding.",
            "type": "integer",
            "format": "pixels",
            "x-format-description": "pixels"
          },
          "pixel_height": {
            "description": "The picture width in pixels of the original video before transcoding.",
            "type": "integer",
            "format": "pixels",
            "x-format-description": "pixels"
          },
          "level": {
            "type": "string",
            "description": "A set of constraints that indicate a degree of required decoder performance.\nThis parameter is used for compatibility with old devices.\n",
            "x-api-allow": [
              "smartcam"
            ]
          },
          "profile": {
            "description": "A specific codec-dependent profile of the output video.\nThe profile allows to assume if the track can be played on a particular device.\n",
            "type": "string",
            "x-api-allow": [
              "smartcam"
            ]
          },
          "bframes": {
            "description": "Average number of B-frames in a GOP. B-frames contain links to keyframes and P-frames before and after themselves.\nB-frames help to compress the video. However, some players impose limitations on this number: usually no more than 2 B-frames are used.\nThis value also defines the GOP structure - the repeated pattern of frames after the keyframe: P, BP, BBP, BBBP, or BBBBP.\n",
            "type": "integer",
            "x-notice": "calculated number of bframes for statistic",
            "example": 3
          },
          "gop_size": {
            "description": "The number of frames in a group of pictures (GOP). \nThe encoder will create all GOPs of an exactly identical size - as specified in this option.\nA bigger GOP can be good for video compression but it can result in big zap-time (the duration of time between changing a channel and displaying a new channel.)\n",
            "type": "integer",
            "x-api-allow": [
              "smartcam"
            ]
          }
        }
      },
      "track_info_audio": {
        "allOf": [
          {
            "$ref": "#/components/schemas/track_info_base"
          },
          {
            "$ref": "#/components/schemas/track_info_base_configurable"
          },
          {
            "type": "object",
            "properties": {
              "codec": {
                "description": "Codec of the track. Different codecs do **not** get the same track.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/frame_codec"
                  }
                ],
                "example": "h264",
                "x-api-allow": [
                  "smartcam",
                  "iris-hal"
                ]
              }
            }
          },
          {
            "$ref": "#/components/schemas/track_info_audio_specific"
          }
        ]
      },
      "track_info_audio_specific": {
        "type": "object",
        "properties": {
          "channels": {
            "description": "The number of audio channels.",
            "type": "integer",
            "example": 2,
            "x-api-allow": [
              "smartcam"
            ]
          },
          "sample_rate": {
            "description": "Sample rate, in hertz -\nthe number of samples per second taken from a continuous signal to make a discrete or digital signal.\n",
            "type": "integer",
            "example": 8000,
            "x-api-allow": [
              "smartcam"
            ]
          },
          "language": {
            "description": "Language value of the track, if applicable.",
            "type": "string",
            "example": "eng"
          }
        }
      },
      "track_info_text": {
        "allOf": [
          {
            "$ref": "#/components/schemas/track_info_base"
          },
          {
            "$ref": "#/components/schemas/track_info_base_configurable"
          },
          {
            "type": "object",
            "properties": {
              "codec": {
                "description": "Codec of the track. Different codecs do **not** get the same track.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/frame_codec"
                  }
                ],
                "example": "h264",
                "x-api-allow": [
                  "smartcam",
                  "iris-hal"
                ]
              }
            }
          },
          {
            "$ref": "#/components/schemas/track_info_text_specific"
          }
        ]
      },
      "track_info_text_specific": {
        "type": "object",
        "properties": {
          "language": {
            "description": "Language value of the track, if applicable.",
            "type": "string",
            "example": "eng"
          }
        }
      },
      "track_info_application": {
        "allOf": [
          {
            "$ref": "#/components/schemas/track_info_base"
          },
          {
            "$ref": "#/components/schemas/track_info_base_configurable"
          },
          {
            "type": "object",
            "properties": {
              "codec": {
                "description": "Codec of the track. Different codecs do **not** get the same track.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/frame_codec"
                  }
                ],
                "example": "h264",
                "x-api-allow": [
                  "smartcam",
                  "iris-hal"
                ]
              }
            }
          },
          {
            "$ref": "#/components/schemas/track_info_application_specific"
          }
        ]
      },
      "track_info_application_specific": {
        "type": "object",
        "properties": {
          "language": {
            "description": "Language value of the track, if applicable.",
            "type": "string",
            "example": "eng"
          }
        }
      },
      "track_info_metadata": {
        "allOf": [
          {
            "$ref": "#/components/schemas/track_info_base"
          },
          {
            "$ref": "#/components/schemas/track_info_base_configurable"
          },
          {
            "type": "object",
            "properties": {
              "codec": {
                "description": "Codec of the track. Different codecs do **not** get the same track.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/frame_codec"
                  }
                ],
                "example": "h264",
                "x-api-allow": [
                  "smartcam",
                  "iris-hal"
                ]
              }
            }
          }
        ]
      },
      "track_info_full": {
        "allOf": [
          {
            "$ref": "#/components/schemas/track_info_base"
          },
          {
            "$ref": "#/components/schemas/track_info_base_configurable"
          },
          {
            "type": "object",
            "properties": {
              "codec": {
                "description": "Codec of the track. Different codecs do **not** get the same track.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/frame_codec"
                  }
                ],
                "example": "h264",
                "x-api-allow": [
                  "smartcam",
                  "iris-hal"
                ]
              }
            }
          },
          {
            "$ref": "#/components/schemas/track_info_audio_specific"
          },
          {
            "$ref": "#/components/schemas/track_info_video_specific"
          },
          {
            "$ref": "#/components/schemas/track_info_video_configurable"
          }
        ]
      },
      "closed_captions": {
        "type": "object",
        "properties": {
          "language": {
            "description": "Language of closed captions.",
            "type": "string",
            "example": "eng"
          },
          "name": {
            "description": "Under what name the audio track will be displayed on the player.",
            "type": "string",
            "example": "English"
          }
        }
      },
      "media_info": {
        "allOf": [
          {
            "$ref": "#/components/schemas/media_info_specific"
          },
          {
            "$ref": "#/components/schemas/media_info_common"
          }
        ]
      },
      "media_info_specific": {
        "type": "object",
        "properties": {
          "flow_type": {
            "description": "Whether it is a file with a finite start and end time or a live stream.",
            "oneOf": [
              {
                "const": "file"
              },
              {
                "const": "stream"
              },
              {
                "const": "dvr_file"
              },
              {
                "const": "dvr_stream"
              }
            ],
            "type": "string",
            "example": "stream"
          },
          "tracks": {
            "description": "Information about available tracks (video, audio, or text).",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/track_info"
                }
              ]
            },
            "type": "array",
            "default": [],
            "x-api-allow": [
              "smartcam"
            ]
          },
          "duration": {
            "type": "number",
            "format": "ticks",
            "description": "Duration of the media, if applicable.",
            "x-format-description": "ticks"
          }
        }
      },
      "media_info_common": {
        "type": "object",
        "properties": {
          "provider": {
            "description": "The media provider of this content.",
            "type": "string",
            "example": "Netflix"
          },
          "title": {
            "description": "Human-readable title of the media.",
            "type": "string",
            "example": "Bunny"
          },
          "stream_id": {
            "type": "integer",
            "example": 253,
            "description": "The identifier of the transport stream for MPEG TS streams."
          },
          "program_id": {
            "type": "integer",
            "example": 110,
            "description": "The program ID for MPEG TS streams."
          }
        }
      },
      "abstract_manifest": {
        "description": "List of periods. Each period has single media_info, single DRM key (if any), no significant gaps.\n",
        "type": "object",
        "properties": {
          "mutability": {
            "description": "Mutability information. This property shows how the manifest will change on future requests\n",
            "type": "string",
            "oneOf": [
              {
                "title": "Live",
                "const": "live",
                "description": "New segments will be added, and old segments will disappear"
              },
              {
                "title": "Event (append-only)",
                "const": "event",
                "description": "New segments will be appended, but all previously seen segments will be kept"
              },
              {
                "title": "Static (VOD)",
                "const": "static",
                "description": "No changes will be made to this manifest"
              }
            ]
          },
          "segment_prefix": {
            "description": "Segment path template is `/{stream_name}/{segment_prefix}-{segment_dts}.{segment_extension}`\n\nThis field is a prefix to insert into segment URL template.\nE.g. when desired format is mpegts and the segment is stored in DVR,\nsegments of the stream 'clock' would be accessible by url `http://example.com/clock/dvr-1653316321820.ts`\n",
            "type": "string",
            "enum": [
              "live",
              "dvr",
              "vod"
            ]
          },
          "periods": {
            "description": "Continuous playback periods.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/abstract_playback_period"
            }
          }
        }
      },
      "abstract_playback_period": {
        "type": "object",
        "properties": {
          "dts": {
            "description": "first frame's DTS",
            "type": "integer",
            "format": "milliseconds",
            "example": 1653316321820,
            "x-format-description": "milliseconds"
          },
          "duration": {
            "description": "period duration",
            "type": "integer",
            "format": "milliseconds",
            "example": 738270,
            "x-format-description": "milliseconds"
          },
          "media_info": {
            "description": "Technical information about the output media content.",
            "allOf": [
              {
                "$ref": "#/components/schemas/media_info"
              }
            ]
          },
          "drm": {
            "description": "Available protection systems",
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/stream_drm_hls"
                },
                {
                  "$ref": "#/components/schemas/stream_drm_cenc"
                }
              ],
              "discriminator": {
                "propertyName": "format"
              }
            }
          },
          "segments": {
            "description": "The list of stream segments.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/stream_segment"
            }
          }
        }
      },
      "stream_segment": {
        "description": "Stream segment, typical data block for segmented protocols (HLS, DASH, MSS, M4F).\nUsually contains few seconds of media, starting with a video keyframe.\n",
        "type": "object",
        "properties": {
          "dts": {
            "description": "first frame's DTS",
            "type": "integer",
            "format": "milliseconds",
            "example": 1653316321820,
            "x-format-description": "milliseconds"
          },
          "duration": {
            "description": "segment duration",
            "type": "integer",
            "format": "milliseconds",
            "example": 5000,
            "x-format-description": "milliseconds"
          },
          "drm_iv": {
            "description": "Initialization Vector for DRM",
            "type": "string",
            "format": "hexbinary",
            "x-format-description": "hexbinary"
          }
        }
      },
      "stream_drm_hls": {
        "description": "HLS-specific DRM info",
        "type": "object",
        "properties": {
          "format": {
            "description": "Period format.",
            "const": "hls"
          },
          "method": {
            "description": "Encryption method.\nNote: instead of specifying method=none, the whole hls object is omitted\n",
            "type": "string",
            "enum": [
              "aes_128",
              "sample_aes"
            ]
          },
          "uri": {
            "description": "A URI that specifies how to obtain the key",
            "type": "string",
            "example": "http://keyserver.example.com/file.key"
          },
          "keyformat": {
            "description": "Specifies how the key is represented in the resource identified by the URI",
            "type": "string",
            "default": "identity",
            "enum": [
              "identity",
              "com.apple.streamingkeydelivery"
            ]
          },
          "keyformatversions": {
            "description": "This attribute can be used to indicate which version(s) of a keyformat this instance complies with.\n",
            "type": "array",
            "items": {
              "type": "integer",
              "minimum": 1
            }
          }
        }
      },
      "stream_drm_cenc": {
        "description": "DRM info specific to CENC formats (DASH, fMP4 HLS, CMAF)",
        "type": "object",
        "properties": {
          "format": {
            "description": "Period format.",
            "const": "cenc"
          },
          "system_id": {
            "description": "Protection system ID (see https://dashif.org/identifiers/content_protection/)",
            "type": "string",
            "format": "uuid",
            "example": "edef8ba9-79d6-4ace-a3c8-27dcd51d21ed",
            "x-format-description": "uuid"
          },
          "system_name": {
            "description": "Human-readable protection system name",
            "type": "string",
            "example": "Widevine"
          },
          "key_id": {
            "description": "Protection Key ID",
            "type": "string",
            "format": "uuid",
            "x-format-description": "uuid"
          },
          "header": {
            "description": "PSSH payload",
            "type": "string",
            "format": "base64",
            "x-format-description": "base64"
          }
        }
      },
      "webrtc_sdp": {
        "type": "object",
        "properties": {
          "candidates": {
            "description": "ICE candidates for delivering content. \nICE candidate is a part of SDP that contains information about the network connection.\nA peer should check all of them to understand, which of them is working.\n",
            "externalDocs": {
              "description": "Read more about ICE candidates",
              "url": "https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Connectivity#ice_candidates"
            },
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/webrtc_ice_candidate"
                }
              ]
            }
          },
          "ice_username": {
            "description": "ICE username that uniquely identifies a single ICE interaction session.\nIt is specified in the `a=ice-ufrag:` attribute.\n",
            "type": "string",
            "externalDocs": {
              "description": "Find more information here",
              "url": "https://datatracker.ietf.org/doc/html/rfc5245"
            }
          },
          "ice_password": {
            "description": "ICE password that uniquely identifies a single ICE interaction session.\nIt is specified in the `a=ice-pwd:` attribute.\n",
            "type": "string",
            "externalDocs": {
              "description": "ICE candidates",
              "url": "https://datatracker.ietf.org/doc/html/rfc5245"
            }
          },
          "fingerprint": {
            "description": "ICE fingerprint. \nThis attribute identifies the certificate that will be presented for the TLS session.\n",
            "type": "string",
            "externalDocs": {
              "description": "DTLS Connection fingerprint",
              "url": "https://datatracker.ietf.org/doc/html/rfc4572"
            }
          },
          "fingerprint_digest": {
            "description": "ICE fingerprint digest method. Usually, `sha-256`.",
            "type": "string",
            "enum": [
              "sha256"
            ]
          },
          "tracks": {
            "description": "List of the objects in Flussonic structure that are used to built media parts of SDP (starting with `m` command).\nHere we call them tracks, because of Flussonic naming.\n",
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/webrtc_sdp_track"
                }
              ]
            },
            "default": []
          }
        }
      },
      "webrtc_sdp_track": {
        "type": "object",
        "properties": {
          "id": {
            "description": "Unique identifier of a media track within a session description.\n",
            "type": "string"
          },
          "content": {
            "description": "Content of the track.",
            "allOf": [
              {
                "$ref": "#/components/schemas/frame_content"
              }
            ]
          },
          "payloads": {
            "description": "Payload choice for the track\n",
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/webrtc_sdp_track_payload"
                }
              ]
            },
            "default": []
          },
          "ssrc": {
            "description": "4 byte integer used for track identification",
            "type": "integer"
          },
          "direction": {
            "description": "Direction choice for the track\n",
            "oneOf": [
              {
                "$ref": "#/components/schemas/webrtc_sdp_track_direction"
              }
            ],
            "example": "recvonly"
          },
          "extensions": {
            "description": "RTP header extension mapping",
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/webrtc_sdp_track_extension"
                }
              ]
            },
            "default": []
          }
        }
      },
      "webrtc_sdp_track_payload": {
        "type": "object",
        "properties": {
          "payload_type": {
            "description": "The value used in `m=audio 9 RTP/SAVPF 111 103 104 9 0 8 106 105 13 126` and\n`a=rtpmap:9 G722/8000`\n",
            "type": "integer"
          },
          "codec": {
            "description": "This payload codec.",
            "allOf": [
              {
                "$ref": "#/components/schemas/frame_codec"
              }
            ]
          },
          "timescale": {
            "type": "integer",
            "description": "Divider of RTP timestamps."
          },
          "channels": {
            "type": "integer",
            "description": "How many audio channels are used."
          },
          "feedbacks": {
            "description": "The list of supported feedback options.",
            "allOf": [
              {
                "$ref": "#/components/schemas/webrtc_rtcp_feedbacks"
              }
            ]
          },
          "retransmit_payload_type": {
            "description": "`a=rtpmap:102 H264/90000\na=rtpmap:121 rtx/90000\na=fmtp:121 apt=102`\n\nAccording to https://tools.ietf.org/html/rfc4588 codec rtx means\nthat it is possible to request retransmit of packets.\n`apt` (associated payload type) points at this payload that is retransmitable.\n"
          },
          "h264_packing": {
            "type": "string",
            "enum": [
              "fua"
            ],
            "default": "fua",
            "description": "`packetization-mode=1` in SDP means that H264 can be packed with FU-A.\n`packetization-mode=0` is not practically used.\n"
          },
          "codec_specific": {
            "description": "`a=fmtp:111 minptime=10; useinbandfec=1\na=fmtp:98 profile-id=2\na=fmtp:102 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42001f\na=fmtp:120 max-fs=12288;max-fr=60\na=fmtp:111 minptime=10`\n\nThis attribute allows parameters that are specific to a\nparticular format to be conveyed in a way that SDP does not\nhave to understand them.\n\nhttps://datatracker.ietf.org/doc/html/rfc3264:\n  The interpretation of fmtp parameters in an offer depends on the\nparameters. In many cases, those parameters describe specific\nconfigurations of the media format, and should therefore be processed\nas the media format value itself would be.  This means that the same\nfmtp parameters with the same values MUST be present in the answer if\nthe media format they describe is present in the answer.\n",
            "externalDocs": {
              "description": "Find more information here",
              "url": "https://datatracker.ietf.org/doc/html/rfc4566#section-6"
            },
            "type": "string"
          }
        }
      },
      "webrtc_sdp_track_direction": {
        "type": "string",
        "enum": [
          "sendonly",
          "recvonly",
          "sendrecv",
          "inactive"
        ]
      },
      "webrtc_sdp_track_extension": {
        "type": "object",
        "properties": {
          "id": {
            "description": "Extension ID which is using for mapping. Must be in range 1..14\nEach ID in this range MUST be used only once for each media\n(or only once if the mappings are session level)\n",
            "type": "integer",
            "minimum": 1,
            "maximum": 14
          },
          "name": {
            "description": "Each extension has unique internal name which is internaly mapped\nto the extension URI one to one.\nExtension URI precisely identifies the format and meaning of the extension.\n",
            "type": "string"
          }
        }
      },
      "webrtc_rtcp_feedbacks": {
        "type": "object",
        "properties": {
          "ccm fir": {
            "description": "Indicates the use of Codec Control Messages (CCMs) with Full Intra Request (FIR) command.",
            "type": "boolean",
            "default": false,
            "externalDocs": {
              "description": "Find more information here",
              "url": "https://datatracker.ietf.org/doc/html/rfc5104"
            }
          },
          "nack": {
            "description": "Indicates the use of Negative ACKnowledgement (NACK) packet loss indicators.",
            "type": "boolean",
            "default": false,
            "externalDocs": {
              "description": "Find more information here",
              "url": "https://datatracker.ietf.org/doc/html/rfc3941"
            }
          },
          "nack pli": {
            "description": "Indicates the use of Picture Loss Indication (PLI) feedback together with NACK.",
            "type": "boolean",
            "default": false,
            "externalDocs": {
              "description": "Find more information here",
              "url": "https://datatracker.ietf.org/doc/html/rfc4585"
            }
          },
          "goog-remb": {
            "description": "Indicates the use Receiver Estimated Maximum Bitrate (REMB) mechanism for bitrate selection.",
            "type": "boolean",
            "default": false,
            "externalDocs": {
              "description": "Find more information here",
              "url": "https://datatracker.ietf.org/doc/html/draft-alvestrand-rmcat-remb-03"
            }
          },
          "transport-cc": {
            "description": "Indicates the use of Transport-wide Congestion Control (TWCC) mechanism for bitrate selection.",
            "type": "boolean",
            "default": false,
            "externalDocs": {
              "description": "Find more information here",
              "url": "https://datatracker.ietf.org/doc/html/draft-holmer-rmcat-transport-wide-cc-extensions-01"
            }
          }
        }
      },
      "webrtc_ice_candidate": {
        "type": "object",
        "properties": {
          "transport": {
            "description": "Transport protocol for the candidate",
            "allOf": [
              {
                "$ref": "#/components/schemas/webrtc_transport"
              }
            ]
          },
          "ip": {
            "description": "Offered IP address",
            "type": "string",
            "format": "ip",
            "x-format-description": "ip"
          },
          "port": {
            "description": "Offered port",
            "type": "integer"
          }
        }
      },
      "webrtc_transport": {
        "type": "string",
        "oneOf": [
          {
            "title": "UDP",
            "const": "udp"
          },
          {
            "title": "TCP",
            "const": "tcp"
          }
        ]
      },
      "hls_master_playlist": {
        "type": "object",
        "properties": {
          "independent_segments": {
            "description": "Signalization of independent segments\n",
            "type": "boolean"
          },
          "alternative_renditions": {
            "description": "The EXT-X-MEDIA tag is used to relate Media Playlists that contain\nalternative Renditions of the same content.  For\nexample, three EXT-X-MEDIA tags can be used to identify audio-only\nMedia Playlists that contain English, French and Spanish Renditions\nof the same presentation.  Or two EXT-X-MEDIA tags can be used to\nidentify video-only Media Playlists that show two different camera\nangles.\n",
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/hls_playlist_media_link"
                }
              ]
            },
            "default": []
          },
          "variant_streams": {
            "description": "The EXT-X-STREAM-INF tag specifies a Variant Stream, which is a set\nof Renditions which can be combined to play the presentation.  The\nattributes of the tag provide information about the Variant Stream.\n",
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/hls_playlist_stream_inf_link"
                }
              ]
            },
            "default": []
          },
          "image_streams": {
            "description": "The EXT-X-I-FRAME-STREAM-INF tag identifies a Media Playlist file\ncontaining the I-frames of a multimedia presentation.\nThe EXT-X-IMAGE-STREAM-INF tag identifies an Image Media Playlist file\ncontaining Images in a compressed graphic image format.\nIt stands alone, in that it does not apply to a particular URI in the\nMultivariant Playlist.\n",
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/hls_playlist_image_stream_inf_link"
                }
              ]
            },
            "default": []
          }
        }
      },
      "hls_playlist_media_link": {
        "type": "object",
        "properties": {
          "type": {
            "description": "Content of the referenced url, corresponds to TYPE attribute",
            "type": "string",
            "enum": [
              "audio",
              "subtitles",
              "closed_captions"
            ]
          },
          "uri": {
            "description": "URI of the playlist with segments and exact bitrate.\nCan be:\n- relative\n- absolute\n- full\n\nRelative is used in regular situations.\n\nAbsolute CAN be used in vod_mbr when another medias are referenced.\n\nFull can be used in CDN scenario, however we prefer to pass playlists through flussonic.\n",
            "type": "string",
            "format": "url",
            "x-format-description": "url"
          },
          "group_id": {
            "description": "Specifies the group to which the Rendition belongs.",
            "type": "string"
          },
          "language": {
            "description": "One of the standard Tags for Identifying Languages, which identifies the primary\nlanguage used in the Rendition.\n",
            "type": "string"
          },
          "name": {
            "description": "Human-readable description of the Rendition.",
            "type": "string"
          },
          "default": {
            "description": "Flag indicates that this media is default",
            "type": "boolean"
          },
          "instream_id": {
            "description": "A Rendition within the segments in the Media Playlist.\nThis attribute is REQUIRED if the TYPE attribute is CLOSED-CAPTIONS,\nin which case it MUST have one of the values: \"CC1\", \"CC2\", \"CC3\", \"CC4\", or \"SERVICEn\"\nwhere n MUST be an integer between 1 and 63 (e.g., \"SERVICE9\" or \"SERVICE42\").\n\nFor all other TYPE values, the INSTREAM-ID MUST NOT be specified.\n",
            "type": "string"
          }
        }
      },
      "hls_playlist_stream_inf_link": {
        "type": "object",
        "properties": {
          "uri": {
            "description": "URI of the playlist with segments and exact bitrate.\nCan be:\n- relative\n- absolute\n- full\n\nRelative is used in regular situations.\n\nAbsolute CAN be used in vod_mbr when another medias are referenced.\n\nFull can be used in CDN scenario, however we prefer to pass playlists through flussonic.\n",
            "type": "string",
            "format": "url",
            "x-format-description": "url"
          },
          "bandwidth": {
            "description": "Peak segment bit rate of the Variant Stream",
            "type": "integer"
          },
          "average_bandwidth": {
            "description": "Average segment bit rate of the Variant Stream.",
            "type": "integer"
          },
          "codecs": {
            "description": "List of formats, where each format specifies a media sample type that is\npresent in one or more Renditions specified by the Variant Stream.\nSee https://tools.ietf.org/html/rfc6381 for a formal, detailed description of this attribute.\n",
            "type": "array",
            "items": {
              "type": "string"
            },
            "example": [
              "avc1.42c00d",
              "mp4a.40.2"
            ]
          },
          "width": {
            "description": "Width is a part of the RESOLUTION attribute\nThe optimal pixel resolution at which to display all the video in the Variant Stream.\n",
            "type": "integer"
          },
          "height": {
            "description": "Height is a part of the RESOLUTION attribute\nThe optimal pixel resolution at which to display all the video in the Variant Stream.\n",
            "type": "integer"
          },
          "frame_rate": {
            "description": "Maximum frame rate for all the video in the Variant Stream",
            "type": "integer"
          },
          "audio": {
            "description": "`group_id` property of an `hls_playlist_media_link` in the same `hls_master_playlist`\nIndicates the set of audio Renditions that SHOULD be used when playing the presentation.\n",
            "type": "string"
          },
          "subtitles": {
            "description": "`group_id` property of an `hls_playlist_media_link` in the same `hls_master_playlist`\nIndicates the set of subtitle Renditions that SHOULD be used when playing the presentation.\n",
            "type": "string"
          },
          "closed_captions": {
            "description": "`group_id` property of an `hls_playlist_media_link` in the same `hls_master_playlist`\nIndicates the set of closed captions Renditions that SHOULD be used when playing the presentation.\n",
            "type": "string"
          }
        }
      },
      "hls_playlist_image_stream_inf_link": {
        "type": "object",
        "properties": {
          "type": {
            "description": "Content of the referenced url, selects a tag between '#EXT-X-I-FRAME-STREAM-INF' and '#EXT-X-IMAGE-STREAM-INF'",
            "type": "string",
            "enum": [
              "i_frame",
              "image"
            ]
          },
          "uri": {
            "description": "URI that identifies the I-frame (or Image) Media Playlist file.\nCan be:\n- relative\n- absolute\n- full\n\nRelative is used in regular situations.\n\nAbsolute CAN be used in vod_mbr when another medias are referenced.\n\nFull can be used in CDN scenario, however we prefer to pass playlists through flussonic.\n",
            "type": "string",
            "format": "url",
            "x-format-description": "url"
          },
          "bandwidth": {
            "description": "Peak segment bit rate of the Variant Stream",
            "type": "integer"
          },
          "average_bandwidth": {
            "description": "Average segment bit rate of the Variant Stream.",
            "type": "integer"
          },
          "codecs": {
            "description": "A list of compressed graphic image formats present in the Image Media Playlist.\nSee https://tools.ietf.org/html/rfc6381 for a formal, detailed description of this attribute.\n",
            "type": "array",
            "items": {
              "type": "string"
            },
            "example": [
              "jpeg"
            ]
          },
          "width": {
            "description": "Width is a part of the RESOLUTION attribute\nThe optimal pixel resolution at which to display all the video in the Variant Stream.\n",
            "type": "integer"
          },
          "height": {
            "description": "Height is a part of the RESOLUTION attribute\nThe optimal pixel resolution at which to display all the video in the Variant Stream.\n",
            "type": "integer"
          }
        }
      },
      "hls_bitrate_playlist": {
        "type": "object",
        "properties": {
          "version": {
            "description": "HLS playlists have protocol version.\n",
            "type": "integer"
          },
          "playlist_type": {
            "description": "Playlist can be live, event (with fixed beginning) and vod\n",
            "type": "string",
            "enum": [
              "live",
              "event",
              "vod"
            ]
          },
          "target_duration": {
            "description": "Average duration of each segment of this playlist and future updates.\n",
            "type": "number"
          },
          "chunk_duration": {
            "description": "`#EXT-X-PART-INF:PART-TARGET=0.443` target duration of low latency chunk.\n",
            "type": "number"
          },
          "media_sequence": {
            "description": "Number of first segment in this playlist.\n\nImportant for identifying segments after refresh.\n",
            "type": "integer"
          },
          "discontinuity_sequence": {
            "description": "Discontinuity sequence counter (the number of times discontinuity segments were removed from the playlist).",
            "type": "integer"
          },
          "datetime": {
            "description": "Precise UTC timestamp of first segment in this playlist.\n",
            "type": "string",
            "format": "date_time",
            "x-format-description": "date_time"
          },
          "segments": {
            "description": "List of referenced segments.\nMay be sliding.\n",
            "type": "array",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/hls_playlist_segment"
                }
              ]
            }
          }
        }
      },
      "hls_playlist_segment": {
        "type": "object",
        "properties": {
          "url": {
            "description": "Segment url",
            "type": "string"
          },
          "discontinuity": {
            "description": "Indicate playback gap\n",
            "type": "boolean"
          },
          "key_details": {
            "description": "DRM key details for the segment.",
            "type": "string"
          },
          "duration": {
            "description": "This segment duration in seconds\n",
            "type": "number"
          }
        }
      },
      "dvr_range": {
        "type": "object",
        "properties": {
          "from": {
            "description": "The beginning of the recorded DVR range. Use opened_at instead.\nMention that opened_at has milliseconds\n",
            "type": "integer",
            "format": "utc",
            "example": 1525186456,
            "deprecated": true,
            "x-delete-at": 24.11,
            "x-format-description": "Unix timestamp in seconds",
            "minimum": 1000000000,
            "maximum": 10000000000
          },
          "duration": {
            "description": "The duration of the recorded DVR range.\nUse closed_at instead of this field. \n",
            "type": "integer",
            "format": "seconds",
            "example": 28800,
            "deprecated": true,
            "x-delete-at": 24.11,
            "x-format-description": "seconds"
          },
          "opened_at": {
            "type": "integer",
            "format": "utc_ms",
            "description": "The time when this range was started. Naming is standard for whole flussonic ecosystem.\n\nIs a replacement for field `from`\n",
            "examples": {
              "default": {
                "value": 1637094994000
              }
            },
            "x-format-description": "Unix timestamp in milliseconds",
            "minimum": 1000000000000,
            "maximum": 10000000000000
          },
          "closed_at": {
            "type": "integer",
            "format": "utc_ms",
            "description": "The the of the last recorded data.\n\nPlease notice that closed_at could be changed. There are two reasons.\n- Cleaner process reduced data. Read [more](https://flussonic.com/doc/api/reference/#tag/stream/operation/stream_get/response%7Cdvr%7Cepisodes_url).\n- Recording is still working. Near real-time value means that DVR is active at the moment.\n\nThis is a replacement for `duration` field\n",
            "examples": {
              "default": {
                "value": 1637094994000
              }
            },
            "x-format-description": "Unix timestamp in milliseconds",
            "minimum": 1000000000000,
            "maximum": 10000000000000
          }
        }
      },
      "public_stream_stats": {
        "type": "object",
        "properties": {
          "status": {
            "description": "Indicates the status of the stream.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/stream_status"
              }
            ]
          },
          "dvr_info": {
            "description": "The information about the recorded DVR archive.",
            "allOf": [
              {
                "$ref": "#/components/schemas/dvr_info"
              }
            ]
          },
          "last_dts_at": {
            "type": "number",
            "format": "utc_ms",
            "description": "The time when the last time frame was sent to the stream output (in UTC).",
            "example": 1636383841974,
            "x-format-description": "Unix timestamp in milliseconds",
            "minimum": 1000000000000,
            "maximum": 10000000000000
          },
          "media_info": {
            "allOf": [
              {
                "$ref": "#/components/schemas/media_info"
              }
            ],
            "description": "Technical information about the output media content."
          }
        }
      },
      "stream_status": {
        "type": "string",
        "oneOf": [
          {
            "title": "Running",
            "const": "running",
            "description": "Input is OK, stream is ready to be served to your audience."
          },
          {
            "title": "Waiting",
            "const": "waiting",
            "description": "Flussonic awaits for input (publish) or it's an 'on demand' stream waiting for client."
          },
          {
            "title": "Error",
            "const": "error",
            "description": "Something is wrong and Flussonic is not able to serve the stream to your audience."
          }
        ]
      },
      "public_stream_config": {
        "type": "object",
        "properties": {
          "instance_id": {
            "description": "Server instance id.",
            "type": "string"
          },
          "name": {
            "type": "string",
            "format": "media_name",
            "description": "Globally unique stream name.",
            "x-primary-key": true,
            "examples": {
              "default": {
                "value": "hockey1"
              }
            },
            "x-format-description": "media_name"
          },
          "title": {
            "description": "Human-readable title of the stream. Provided for SDT MPEG-TS table or\nSDP RTSP title parameter.\n",
            "type": "string",
            "example": "Hockey channel"
          },
          "provider": {
            "description": "Human-readable name of the content provider. Used, for example, for MPEG-TS.      \n",
            "type": "string",
            "example": "SportsTV"
          },
          "logo": {
            "description": "Overlay logo.",
            "allOf": [
              {
                "$ref": "#/components/schemas/web_logo_spec"
              }
            ]
          },
          "auth_token": {
            "allOf": [
              {
                "$ref": "#/components/schemas/auth_token"
              }
            ],
            "description": "Configure key name of query string key-value pair for token authentication\n"
          },
          "stats": {
            "description": "Stream's metrics and other statistical information.",
            "allOf": [
              {
                "$ref": "#/components/schemas/public_stream_stats"
              }
            ],
            "readOnly": true
          }
        },
        "required": [
          "name"
        ]
      },
      "web_logo_spec": {
        "type": "object",
        "properties": {
          "height": {
            "description": "Set the specified height for the logo.",
            "type": "integer",
            "example": 100
          },
          "width": {
            "description": "Set the specified width for the logo.",
            "type": "integer",
            "example": 200
          },
          "left": {
            "description": "Change the position of the logo to the left.",
            "type": "integer",
            "example": 15
          },
          "top": {
            "description": "Change the position of the logo to the top.",
            "type": "integer",
            "example": 15
          },
          "right": {
            "description": "Change the position of the logo to the right.",
            "type": "integer"
          },
          "bottom": {
            "description": "Change the position of the logo to the bottom.",
            "type": "integer"
          }
        }
      },
      "dvr_info": {
        "type": "object",
        "properties": {
          "from": {
            "type": "integer",
            "format": "utc",
            "description": "The UTC timestamp of the first recording in this archive.",
            "example": 1641045644,
            "x-format-description": "Unix timestamp in seconds",
            "minimum": 1000000000,
            "maximum": 10000000000
          },
          "depth": {
            "type": "integer",
            "format": "seconds",
            "description": "The time interval between the start of the *first* recording segment and the end of the *last* one.",
            "example": 259200,
            "x-format-description": "seconds"
          },
          "ranges": {
            "deprecated": true,
            "x-delete-at": 24.09,
            "description": "The list of DVR ranges. The param is replaced with `ranges_list` method.",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/dvr_range"
                }
              ]
            },
            "type": "array"
          },
          "bytes": {
            "description": "The size of the recorded archive.",
            "type": "integer",
            "format": "bytes",
            "example": 129600000000,
            "x-format-description": "bytes"
          },
          "disk_size": {
            "description": "The size of the recorded archive. Please, use bytes instead.",
            "type": "integer",
            "format": "bytes",
            "example": 1099511627776,
            "deprecated": true,
            "x-delete-at": 25.07,
            "x-format-description": "bytes"
          },
          "duration": {
            "type": "integer",
            "format": "seconds",
            "description": "A total duration of the recorded segments, excluding recording gaps.\nIt can be smaller than depth if you have gaps.\n",
            "example": 172800,
            "x-format-description": "seconds"
          }
        },
        "required": [
          "from",
          "depth",
          "ranges"
        ]
      },
      "public_streams_list": {
        "allOf": [
          {
            "$ref": "#/components/schemas/collection_response"
          },
          {
            "type": "object",
            "properties": {
              "streams": {
                "items": {
                  "$ref": "#/components/schemas/public_stream_config"
                },
                "type": "array",
                "description": "List of fetched streams according to the query parameters."
              }
            }
          }
        ]
      },
      "stream_dvr_ranges_list": {
        "allOf": [
          {
            "$ref": "#/components/schemas/collection_response"
          },
          {
            "type": "object",
            "properties": {
              "ranges": {
                "description": "List of DVR ranges.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/dvr_range"
                }
              }
            }
          }
        ]
      }
    },
    "parameters": {
      "name": {
        "name": "name",
        "in": "path",
        "description": "The name of a stream or a VOD file. It may be multi-segment, i.e. `/part1/part2/part3`.\n\nFor a VOD file, it consists of the VOD storage name and a path to the file within the storage.\n",
        "required": true,
        "schema": {
          "type": "string"
        },
        "examples": {
          "stream": {
            "summary": "Stream name example",
            "value": "clock"
          },
          "vod": {
            "summary": "VOD file name example",
            "value": "vod/movies/bunny.mp4"
          }
        }
      },
      "separate_audio": {
        "name": "separate_audio",
        "in": "query",
        "description": "Whether audio tracks are specified separately in the playlist.\n\nUsed for players like Samsung TV or browsers that support MSE.  \nSuch players and browsers can't switch between  \nmultiple audio tracks (for instance, for different languages)  \nand don't display such audio tracks. For such cases,  \nFlussonic can create a playlist with separate audio.  \n",
        "schema": {
          "type": "boolean",
          "example": true
        },
        "required": false
      },
      "thumbnails": {
        "name": "thumbnails",
        "in": "query",
        "description": "Applicable to a VOD file only (ignored for a live stream).\n\nIf specified, the thumbnail playlist is added to the primary playlist.\n\nExample of the thumbnail playlist:\n\n```\n#EXT-X-IMAGE-STREAM-INF:BANDWIDTH=10000,RESOLUTION=320x180,CODECS=\"jpeg\",URI=\"images-320x180/tpl-0-34-100.m3u8\"\n```\n\nThis value defines how many thumbnail links will be added  \nto the thumbnail playlist to cover the file duration.  \nThe player adds the thumbnail links to the progress bar  \nat regular intervals. The interval duration between thumbnails  \nis calculated by dividing the total duration of the file by this value.\n\n**Note**: This option requires the following parameters  \nto be included in the VOD location settings:\n\n- `thumbnails enabled=ondemand`\n- `size`\n\nFor example, `thumbnails enabled=ondemand size=320x240;`.\n",
        "schema": {
          "type": "integer",
          "example": 100
        },
        "required": false
      },
      "ago": {
        "name": "ago",
        "in": "path",
        "description": "DVR window size in seconds.\nIt is a duration of a manifest in seconds, so your clients will be able to pause the stream up to this period or rewind it, for example, to the start of a TV show.\n",
        "required": true,
        "schema": {
          "type": "integer",
          "example": 7200
        }
      },
      "delay": {
        "name": "delay",
        "in": "path",
        "description": "Delay in seconds. \n\nFor example, if it is 7200, the stream will be played with a two-hours (7200 seconds) delay.\n",
        "required": true,
        "schema": {
          "type": "integer",
          "example": 7200
        }
      },
      "from": {
        "name": "from",
        "in": "path",
        "description": "Start time of playing the DVR archive in UTC seconds.",
        "required": true,
        "schema": {
          "type": "integer",
          "example": 1641045644
        }
      },
      "duration": {
        "name": "duration",
        "in": "path",
        "description": "The duration of the DVR window in seconds. \n\nYou also can specify `now` for a growing playlist till current time.\n\nIf `from`+`duration` is in the future, the playlist will grow as well until it reaches the specified moment.\n",
        "required": true,
        "schema": {
          "oneOf": [
            {
              "type": "integer",
              "example": 7200
            },
            {
              "type": "string",
              "enum": [
                "now"
              ]
            }
          ]
        }
      },
      "chunk": {
        "name": "chunk",
        "in": "query",
        "description": "Only 'd' value is suppoted now.\nIf present then mss manifest chunk list will be formatted with 'duration' attribute:\n\n< c t=UTC d=Duration />\n< c d=Duration />\n...\n< c d=Duration />\n",
        "required": false,
        "schema": {
          "allOf": [
            {
              "type": "string",
              "enum": [
                "d"
              ]
            }
          ]
        }
      }
    },
    "securitySchemes": {
      "tokenAuth": {
        "type": "apiKey",
        "description": "Token in query string just as defined in https://flussonic.com/doc/authorize-clients/\n",
        "in": "query",
        "name": "token"
      }
    }
  },
  "paths": {
    "/{name}/index.json": {
      "get": {
        "operationId": "abstract_manifest",
        "summary": "abstract manifest",
        "description": "Abstract manifest describing media segments grouped into periods of continious playback\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/abstract_manifest"
                }
              }
            },
            "description": "abstract manifest"
          }
        },
        "tags": [
          "api"
        ]
      }
    },
    "/{name}/archive-{from}-{duration}.json": {
      "get": {
        "operationId": "abstract_dvr_manifest",
        "summary": "abstract DVR manifest",
        "description": "If your stream is already recorded on the server with DVR, you can use this URL to play a specified DVR window, for example,\nyou can play a telecast if you know its beginning and end from EPG.\n\nThis URL works in two modes: file and event. If `duration` is specified as `now`, this\nurl will respond with a growing playlist for playing an event.\n\nIf `duration` is an exact positive number, then the server will respond with playlist, having\nthis requested amount of seconds of video as a file.\n\nNote the following rules:\n\n  * The first segment in this playlist will not start earlier than `from`.\n  * The last segment in this playlist will not start later than `from + duration`.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "$ref": "#/components/parameters/from"
          },
          {
            "$ref": "#/components/parameters/duration"
          },
          {
            "name": "event",
            "in": "query",
            "description": "By default, if the requested numeric range (`archive-1641045644-5000.json`) ends in the future,\nthe returned manifest has `mutability: event` (segments may be appended).\nIt switches to `mutability: static` when the end of range is in past (after 1641050644 UTC in this case).\nThis transition indicates that no segments are going to be added at the next request.\n\nYou may pass `?event=false` parameter if you want `mutability` to be always `static`\n(e.g. to workaround some client behaviour).\n",
            "schema": {
              "type": "boolean",
              "example": false
            },
            "required": false
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/abstract_manifest"
                }
              }
            },
            "description": "abstract manifest"
          }
        },
        "tags": [
          "api"
        ]
      }
    },
    "/{name}/rewind-{ago}.json": {
      "get": {
        "operationId": "abstract_rewind_manifest",
        "summary": "abstract rewind manifest",
        "description": "Nice combination of live and DVR DASH playlists.\n\nThis request gives a playlist with a wide sliding window that allows you to rewind DASH streams and pause them for many hours.\n\nFor example, the playlist \"rewind-7200.json\" allows your clients to pause the stream for up to 2 hours or rewind to the start of a TV show without using catchup URLs.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "$ref": "#/components/parameters/ago"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/abstract_manifest"
                }
              }
            },
            "description": "abstract manifest"
          }
        },
        "tags": [
          "api"
        ]
      }
    },
    "/{name}/timeshift_abs-{from}.json": {
      "get": {
        "operationId": "abstract_timeshift_abs_manifest",
        "summary": "abstract absolute timeshift manifest",
        "description": "If your stream is already recorded on the server with DVR, you can use this URL to play the recorded stream starting at the specified moment of time.\nFor example, you can use it for old STBs or viewing recorded shows with EPG.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "$ref": "#/components/parameters/from"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/abstract_manifest"
                }
              }
            },
            "description": "abstract manifest"
          }
        },
        "tags": [
          "api"
        ]
      }
    },
    "/{name}/timeshift_rel-{delay}.json": {
      "get": {
        "operationId": "abstract_timeshift_rel_manifest",
        "summary": "abstract relative timeshift manifest",
        "description": "If your stream is being recorded on the server with DVR, you can use this URL to play the recorded stream with a specified delay.\nThis can be useful, for example, for TV broadcasting in different time zones, \nso that people in a different time zone watch morning broadcasts in the morning, and not late at night.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "$ref": "#/components/parameters/delay"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/abstract_manifest"
                }
              }
            },
            "description": "abstract manifest"
          }
        },
        "tags": [
          "api"
        ]
      }
    },
    "/{name}/index.ts.m3u8": {
      "get": {
        "operationId": "hls_ts_manifest",
        "summary": "HLS TS live and VOD",
        "description": "Main HLS URL that allows to play a live stream or a VOD file in ts format.\nThis URL responds with [master playlist](https://datatracker.ietf.org/doc/html/rfc8216#section-6.2.4).\n\nExact version of HLS is not defined here, it may vary according to different settings.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "$ref": "#/components/parameters/separate_audio"
          },
          {
            "$ref": "#/components/parameters/thumbnails"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/vnd.apple.mpegurl": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/hls_master_playlist"
                }
              }
            },
            "description": "HLS master playlist with links to other manifests"
          }
        },
        "tags": [
          "hls-ts"
        ]
      }
    },
    "/{name}/video.m3u8": {
      "get": {
        "operationId": "hls_single_playlist_manifest",
        "summary": "HLS live and VOD (Single Playlist)",
        "description": "Main HLS URL that allows to play a live stream or a VOD file in ts format.\nThis URL responds with [master playlist](https://datatracker.ietf.org/doc/html/rfc8216#section-6.2.4).\n\nExact version of HLS is not defined here, it may vary according to different settings.\n\nNon-Apple devices standard URL. All tracks in a single playlist. It is used to watch a multi-language stream\nusing VLC or a set-top box. These ones in violation of the HLS standard, expect the old version of MPEG-TS converted\nto HLS.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "$ref": "#/components/parameters/separate_audio"
          },
          {
            "$ref": "#/components/parameters/thumbnails"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/vnd.apple.mpegurl": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/hls_master_playlist"
                }
              }
            },
            "description": "HLS master playlist with links to other manifests"
          }
        },
        "tags": [
          "hls-ts"
        ]
      }
    },
    "/{name}/rewind-{ago}.ts.m3u8": {
      "get": {
        "operationId": "hls_ts_rewind_manifest",
        "summary": "HLS TS rewind",
        "description": "Nice combination of live and DVR HLS playlists.\n\nThis request gives something like HLS live playlist, but with lot of segments.\n\nIf the player understands that there are too many segments for a plain live playlist,\nit allows to rewind back into DVR window.\n\nWe recommend to take a look at Clappr player that supports this feature out of the box.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "$ref": "#/components/parameters/ago"
          },
          {
            "$ref": "#/components/parameters/separate_audio"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/vnd.apple.mpegurl": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/hls_master_playlist"
                }
              }
            },
            "description": "HLS rewind playlist with links to other manifests"
          }
        },
        "tags": [
          "hls-ts",
          "dvr"
        ]
      }
    },
    "/{name}/archive-{from}-{duration}.ts.m3u8": {
      "get": {
        "operationId": "hls_ts_dvr_manifest",
        "summary": "HLS TS DVR",
        "description": "If your stream is already recorded on the server with DVR, you can use this URL to play a specified DVR window, for example,\nyou can play a telecast if you know its beginning and end from EPG.\n\nThis method returns one of two types of HLS playlists:\n\n* \"VOD\" is suitable for ended TV shows and events, CCTV recordings\n* \"EVENT\" is suitable for current events, webinars, and TV shows.\n\nThis URL is a recommended way to play DVR, because it allows pausing. If a player can seamlessly \nswitch between different URLs, you can make seamless DVR playback with non-overlapping HLS DVR requests.\n",
        "externalDocs": {
          "description": "Find more information here",
          "url": "https://flussonic.com/doc/hls-protocol/#play-hls-catchup"
        },
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "$ref": "#/components/parameters/from"
          },
          {
            "$ref": "#/components/parameters/duration"
          },
          {
            "$ref": "#/components/parameters/separate_audio"
          },
          {
            "$ref": "#/components/parameters/thumbnails"
          },
          {
            "name": "event",
            "in": "query",
            "description": "By default, the VOD playlist is returned unless \"duration=now\"   \nwas requested.\n\nIf the playlist's requested range extends into the future,  \nthe type of the `event` option can be changed to 'EVENT'.\n\nWhen the end of the requested range passes  \n(for `archive-1641045644-5000.m3u8` it's at 1641050644 UTC),  \nthe playlist changes its type to VOD,  \nas no new segments are expected.\n\n**Note**: Most HLS players start playing the VOD playlist  \nfrom the beginning and the EVENT playlist at the live edge  \n(the very end of the playlist).\n\nThe default behavior (always VOD) makes players  \nbehave consistently, but players won't request updated playlists.\n",
            "schema": {
              "type": "boolean",
              "example": true
            },
            "required": false
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/vnd.apple.mpegurl": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/hls_master_playlist"
                }
              }
            },
            "description": "HLS DVR playlist with links to other playlists"
          }
        },
        "tags": [
          "hls-ts",
          "dvr"
        ]
      }
    },
    "/{name}/timeshift_abs-{from}.ts.m3u8": {
      "get": {
        "operationId": "hls_ts_timeshift_abs_manifest",
        "summary": "HLS TS absolute timeshift",
        "description": "If your stream is already recorded on the server with DVR, you can use this URL to play the recorded stream by HLS starting at a specified moment of time.\nFor example, you can use it for old STBs or viewing recoreded shows with EPG.\n\nPlease note that when you use the same timeshift URL several times, any additional requests use the same existing session. \nTherefore the time is not pure \"absolute\" and is still related to the current session.\nTherefore every time you request the same time, you get different part of the video.\nTo solve this problem, you can change the token parameter in every new request to start a new session. \nFor example:\n\n* `http://FLUSSONIC-IP:80/CHANNEL-NAME/timeshift_abs-1430227800.ts.m3u8?token=123` - the first request,\n* `http://FLUSSONIC-IP:80/CHANNEL-NAME/timeshift_abs-1430227800.ts.m3u8?token=124` - the second request, and so on.\n",
        "externalDocs": {
          "description": "Find more information here",
          "url": "https://flussonic.com/doc/hls-protocol/#play-hls-timeshift"
        },
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "$ref": "#/components/parameters/from"
          },
          {
            "$ref": "#/components/parameters/separate_audio"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/vnd.apple.mpegurl": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/hls_master_playlist"
                }
              }
            },
            "description": "HLS DVR manifest with links to other manifests"
          }
        },
        "tags": [
          "hls-ts"
        ]
      }
    },
    "/{name}/timeshift_rel-{delay}.ts.m3u8": {
      "get": {
        "operationId": "hls_ts_timeshift_rel_manifest",
        "summary": "HLS TS relative timeshift",
        "description": "If your stream is being recorded on the server with DVR, you can use this URL to play the recorded stream by HLS with a specified delay.\nThis can be useful, for example, for TV broadcasting in different time zones, \nso that people in a different time zone watch morning broadcasts in the morning, and not late at night.    \n",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "$ref": "#/components/parameters/delay"
          },
          {
            "$ref": "#/components/parameters/separate_audio"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/vnd.apple.mpegurl": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/hls_master_playlist"
                }
              }
            },
            "description": "HLS DVR manifest with links to other manifests"
          }
        },
        "tags": [
          "hls-ts"
        ]
      }
    },
    "/{name}/tracks-{tracks}/mono.m3u8": {
      "get": {
        "operationId": "hls_live_track_mono_manifest",
        "summary": "HLS TS live and VOD tracks",
        "description": "Use this URL to play specified tracks of a live stream or a VOD file.\nIt results in HLS media playlist as a list of segments. Each segment contains the specified tracks only.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "name": "tracks",
            "in": "path",
            "description": "Requested tracks\n",
            "required": true,
            "schema": {
              "type": "string",
              "example": "v1a1"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/vnd.apple.mpegurl": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/hls_bitrate_playlist"
                }
              }
            },
            "description": "HLS bitrate playlist with links to segments"
          }
        },
        "tags": [
          "hls-ts"
        ]
      }
    },
    "/{name}/index.m3u8": {
      "get": {
        "operationId": "hls_manifest",
        "summary": "HLS live and VOD",
        "description": "Main HLS URL that allows to play a live stream or a VOD file.\nThis URL responds with [master playlist](https://datatracker.ietf.org/doc/html/rfc8216#section-6.2.4).\n\nExact version of HLS is not defined here, it may vary according to different settings.\n\nContainer format will be selected automatically depending on media info parameters.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "$ref": "#/components/parameters/separate_audio"
          },
          {
            "$ref": "#/components/parameters/thumbnails"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/vnd.apple.mpegurl": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/hls_master_playlist"
                }
              }
            },
            "description": "HLS master playlist with links to other manifests"
          }
        },
        "tags": [
          "hls"
        ]
      }
    },
    "/{name}/rewind-{ago}.m3u8": {
      "get": {
        "operationId": "hls_rewind_manifest",
        "summary": "HLS rewind",
        "description": "Nice combination of live and DVR HLS playlists.\n\nThis request gives something like HLS live playlist, but with lot of segments.\n\nIf the player understands that there are too many segments for a plain live playlist,\nit allows to rewind back into DVR window.\n\nWe recommend to take a look at Clappr player that supports this feature out of the box.\n\nContainer format will be selected automatically depending on media info parameters.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "$ref": "#/components/parameters/ago"
          },
          {
            "$ref": "#/components/parameters/separate_audio"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/vnd.apple.mpegurl": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/hls_master_playlist"
                }
              }
            },
            "description": "HLS rewind playlist with links to other manifests"
          }
        },
        "tags": [
          "hls",
          "dvr"
        ]
      }
    },
    "/{name}/archive-{from}-{duration}.m3u8": {
      "get": {
        "operationId": "hls_dvr_manifest",
        "summary": "HLS DVR",
        "description": "If your stream is already recorded on the server with DVR, you can use this URL to play a specified DVR window, for example,\nyou can play a telecast if you know its beginning and end from EPG.\n\nThis method returns one of two types of HLS playlists:\n\n* \"VOD\" is suitable for ended TV shows and events, CCTV recordings\n* \"EVENT\" is suitable for current events, webinars, and TV shows.\n\nThis URL is a recommended way to play DVR, because it allows pausing. If a player can seamlessly \nswitch between different URLs, you can make seamless DVR playback with non-overlapping HLS DVR requests.\n\nContainer format will be selected automatically depending on media info parameters.\n",
        "externalDocs": {
          "description": "Find more information here",
          "url": "https://flussonic.com/doc/hls-protocol/#play-hls-catchup"
        },
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "$ref": "#/components/parameters/from"
          },
          {
            "$ref": "#/components/parameters/duration"
          },
          {
            "$ref": "#/components/parameters/separate_audio"
          },
          {
            "$ref": "#/components/parameters/thumbnails"
          },
          {
            "name": "event",
            "in": "query",
            "description": "By default, the VOD playlist is returned unless \"duration=now\"   \nwas requested.\n\nIf the playlist's requested range extends into the future,  \nthe type of the `event` option can be changed to 'EVENT'.\n\nWhen the end of the requested range passes  \n(for `archive-1641045644-5000.m3u8` it's at 1641050644 UTC),  \nthe playlist changes its type to VOD,  \nas no new segments are expected.\n\n**Note**: Most HLS players start playing the VOD playlist  \nfrom the beginning and the EVENT playlist at the live edge  \n(the very end of the playlist).\n\nThe default behavior (always VOD) makes players  \nbehave consistently, but players won't request updated playlists.\n",
            "schema": {
              "type": "boolean",
              "example": true
            },
            "required": false
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/vnd.apple.mpegurl": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/hls_master_playlist"
                }
              }
            },
            "description": "HLS DVR playlist with links to other playlists"
          }
        },
        "tags": [
          "hls",
          "dvr"
        ]
      }
    },
    "/{name}/timeshift_abs-{from}.m3u8": {
      "get": {
        "operationId": "hls_timeshift_abs_manifest",
        "summary": "HLS absolute timeshift",
        "description": "If your stream is already recorded on the server with DVR, you can use this URL to play the recorded stream by HLS starting at a specified moment of time.\nFor example, you can use it for old STBs or viewing recoreded shows with EPG.\n\nPlease note that when you use the same timeshift URL several times, any additional requests use the same existing session. \nTherefore the time is not pure \"absolute\" and is still related to the current session.\nTherefore every time you request the same time, you get different part of the video.\nTo solve this problem, you can change the token parameter in every new request to start a new session. \nFor example:\n\n* `http://FLUSSONIC-IP:80/CHANNEL-NAME/timeshift_abs-1430227800.m3u8?token=123` - the first request,\n* `http://FLUSSONIC-IP:80/CHANNEL-NAME/timeshift_abs-1430227800.m3u8?token=124` - the second request, and so on.\n\nContainer format will be selected automatically depending on media info parameters.\n",
        "externalDocs": {
          "description": "Find more information here",
          "url": "https://flussonic.com/doc/hls-protocol/#play-hls-timeshift"
        },
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "$ref": "#/components/parameters/from"
          },
          {
            "$ref": "#/components/parameters/separate_audio"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/vnd.apple.mpegurl": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/hls_master_playlist"
                }
              }
            },
            "description": "HLS DVR manifest with links to other manifests"
          }
        },
        "tags": [
          "hls"
        ]
      }
    },
    "/{name}/timeshift_rel-{delay}.m3u8": {
      "get": {
        "operationId": "hls_timeshift_rel_manifest",
        "summary": "HLS relative timeshift",
        "description": "If your stream is being recorded on the server with DVR, you can use this URL to play the recorded stream by HLS with a specified delay.\nThis can be useful, for example, for TV broadcasting in different time zones, \nso that people in a different time zone watch morning broadcasts in the morning, and not late at night.\n\nContainer format will be selected automatically depending on media info parameters.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "$ref": "#/components/parameters/delay"
          },
          {
            "$ref": "#/components/parameters/separate_audio"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/vnd.apple.mpegurl": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/hls_master_playlist"
                }
              }
            },
            "description": "HLS DVR manifest with links to other manifests"
          }
        },
        "tags": [
          "hls"
        ]
      }
    },
    "/{name}/index.fmp4.m3u8": {
      "get": {
        "operationId": "hls_fmp4_manifest",
        "summary": "HLS FMP4 live and VOD",
        "description": "Main HLS URL that allows to play a live stream or a VOD file in fragmented mp4 format.\nThis URL responds with [master playlist](https://datatracker.ietf.org/doc/html/rfc8216#section-6.2.4).\n\nExact version of HLS is not defined here, it may vary according to different settings.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "$ref": "#/components/parameters/separate_audio"
          },
          {
            "$ref": "#/components/parameters/thumbnails"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/vnd.apple.mpegurl": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/hls_master_playlist"
                }
              }
            },
            "description": "HLS master playlist with links to other manifests"
          }
        },
        "tags": [
          "hls-fmp4"
        ]
      }
    },
    "/{name}/rewind-{ago}.fmp4.m3u8": {
      "get": {
        "operationId": "hls_fmp4_rewind_manifest",
        "summary": "HLS FMP4 rewind",
        "description": "Nice combination of live and DVR HLS playlists.\n\nThis request gives something like HLS live playlist, but with lot of segments.\n\nIf the player understands that there are too many segments for a plain live playlist,\nit allows to rewind back into DVR window.\n\nWe recommend to take a look at Clappr player that supports this feature out of the box.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "$ref": "#/components/parameters/ago"
          },
          {
            "$ref": "#/components/parameters/separate_audio"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/vnd.apple.mpegurl": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/hls_master_playlist"
                }
              }
            },
            "description": "HLS rewind playlist with links to other manifests"
          }
        },
        "tags": [
          "hls-fmp4",
          "dvr"
        ]
      }
    },
    "/{name}/archive-{from}-{duration}.fmp4.m3u8": {
      "get": {
        "operationId": "hls_fmp4_dvr_manifest",
        "summary": "HLS FMP4 DVR",
        "description": "If your stream is already recorded on the server with DVR, you can use this URL to play a specified DVR window, for example,\nyou can play a telecast if you know its beginning and end from EPG.\n\nThis method returns one of two types of HLS playlists:\n\n* \"VOD\" is suitable for ended TV shows and events, CCTV recordings\n* \"EVENT\" is suitable for current events, webinars, and TV shows.\n\nThis URL is a recommended way to play DVR, because it allows pausing. If a player can seamlessly \nswitch between different URLs, you can make seamless DVR playback with non-overlapping HLS DVR requests.\n",
        "externalDocs": {
          "description": "Find more information here",
          "url": "https://flussonic.com/doc/hls-protocol/#play-hls-catchup"
        },
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "$ref": "#/components/parameters/from"
          },
          {
            "$ref": "#/components/parameters/duration"
          },
          {
            "$ref": "#/components/parameters/separate_audio"
          },
          {
            "$ref": "#/components/parameters/thumbnails"
          },
          {
            "name": "event",
            "in": "query",
            "description": "By default, the VOD playlist is returned unless \"duration=now\"  \nwas requested.\n\nIf the playlist's requested range extends into the future,  \nthe type of the `event` option can be changed to 'EVENT'.\n\nWhen the end of the requested range passes  \n(for `archive-1641045644-5000.m3u8` it's at 1641050644 UTC),  \nthe playlist changes its type to VOD,  \nas no new segments are expected.\n\n**Note**: Most HLS players start playing the VOD playlist  \nfrom the beginning and the EVENT playlist at the live edge  \n(the very end of the playlist).\n\nThe default behavior (always VOD) makes players  \nbehave consistently, but players won't request updated playlists.\n",
            "schema": {
              "type": "boolean",
              "example": true
            },
            "required": false
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/vnd.apple.mpegurl": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/hls_master_playlist"
                }
              }
            },
            "description": "HLS DVR playlist with links to other playlists"
          }
        },
        "tags": [
          "hls-fmp4",
          "dvr"
        ]
      }
    },
    "/{name}/timeshift_abs-{from}.fmp4.m3u8": {
      "get": {
        "operationId": "hls_fmp4_timeshift_abs_manifest",
        "summary": "HLS FMP4 absolute timeshift",
        "description": "If your stream is already recorded on the server with DVR, you can use this URL to play the recorded stream by HLS starting at a specified moment of time.\nFor example, you can use it for old STBs or viewing recoreded shows with EPG.\n\nPlease note that when you use the same timeshift URL several times, any additional requests use the same existing session. \nTherefore the time is not pure \"absolute\" and is still related to the current session.\nTherefore every time you request the same time, you get different part of the video.\nTo solve this problem, you can change the token parameter in every new request to start a new session. \nFor example:\n\n* `http://FLUSSONIC-IP:80/CHANNEL-NAME/timeshift_abs-1430227800.fmp4.m3u8?token=123` - the first request,\n* `http://FLUSSONIC-IP:80/CHANNEL-NAME/timeshift_abs-1430227800.fmp4.m3u8?token=124` - the second request, and so on.\n",
        "externalDocs": {
          "description": "Find more information here",
          "url": "https://flussonic.com/doc/hls-protocol/#play-hls-timeshift"
        },
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "$ref": "#/components/parameters/from"
          },
          {
            "$ref": "#/components/parameters/separate_audio"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/vnd.apple.mpegurl": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/hls_master_playlist"
                }
              }
            },
            "description": "HLS DVR manifest with links to other manifests"
          }
        },
        "tags": [
          "hls-fmp4"
        ]
      }
    },
    "/{name}/timeshift_rel-{delay}.fmp4.m3u8": {
      "get": {
        "operationId": "hls_fmp4_timeshift_rel_manifest",
        "summary": "HLS FMP4 relative timeshift",
        "description": "If your stream is being recorded on the server with DVR, you can use this URL to play the recorded stream by HLS with a specified delay.\nThis can be useful, for example, for TV broadcasting in different time zones, \nso that people in a different time zone watch morning broadcasts in the morning, and not late at night.    \n",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "$ref": "#/components/parameters/delay"
          },
          {
            "$ref": "#/components/parameters/separate_audio"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/vnd.apple.mpegurl": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/hls_master_playlist"
                }
              }
            },
            "description": "HLS DVR manifest with links to other manifests"
          }
        },
        "tags": [
          "hls-fmp4"
        ]
      }
    },
    "/{name}/index.ll.m3u8": {
      "get": {
        "operationId": "llhls_live_manifest",
        "summary": "LL-HLS live manifest",
        "description": "Use this URL to play a stream via Apple Low-Latency HLS.\n\nTo play a stream via this protocol, you should enable CMAF in the stream settings.\nCMAF is a standard that is used to create MP4 fragments compliant with the Low-Latency HLS specification.\n",
        "externalDocs": {
          "description": "Find more information here",
          "url": "https://flussonic.com/doc/hls-protocol/#how-to-configure-ll-hls"
        },
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/vnd.apple.mpegurl": {
                "schema": {
                  "type": "string"
                }
              }
            },
            "description": "LL-HLS Live manifest with links to other manifests"
          }
        },
        "tags": [
          "ll-hls"
        ]
      }
    },
    "/{name}/Manifest.mpd": {
      "get": {
        "operationId": "dash_manifest",
        "summary": "DASH live and VOD",
        "description": "Main DASH URL that allows to play a live stream or a VOD file. \n",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "name": "thumbnails",
            "in": "query",
            "description": "Applicable to a VOD file only (ignored for a live stream).\n\nIf specified, the thumbnail playlist is added to the primary playlist.\n\nExample of the thumbnail playlist:\n\n```\n  <AdaptationSet id=\"3\" mimeType=\"image/jpeg\" contentType=\"image\">\n         <SegmentTemplate media=\"$RepresentationID$/seg-0-$Time$.m4v.jpg\" duration=\"8\"></SegmentTemplate>\n         <Representation bandwidth=\"10000\" id=\"images-320x180\" width=\"320\" height=\"180\">\n            <EssentialProperty schemeIdUri=\"http://dashif.org/guidelines/thumbnail_tile\" value=\"1x1\"/>\n         </Representation>\n  </AdaptationSet>\n```\n\nThis value defines how many thumbnail links will be added  \nto the thumbnail playlist to cover the file duration.  \nThe player adds the thumbnail links to the progress bar  \nat regular intervals. The interval duration between thumbnails  \nis calculated by dividing the total duration of the file by this value.\n\n**Note**: This option requires the following parameters  \nto be included in the VOD location settings:\n\n- `thumbnails enabled=ondemand`\n- `size`\n\nFor example, `thumbnails enabled=ondemand size=320x240;`.\n",
            "schema": {
              "type": "integer",
              "example": 100
            },
            "required": false
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/dash+xml": {
                "schema": {
                  "type": "string"
                }
              }
            },
            "description": "DASH manifest"
          }
        },
        "tags": [
          "dash"
        ]
      }
    },
    "/{name}/rewind-{ago}.mpd": {
      "get": {
        "operationId": "dash_rewind_manifest",
        "summary": "DASH rewind manifest",
        "description": "Nice combination of live and DVR DASH playlists.\n\nThis request gives a playlist with a wide sliding window that allows you to rewind DASH streams and pause them for many hours.\n\nFor example, the playlist \"rewind-7200.mpd\" allows your clients to pause the stream for up to 2 hours or rewind to the start of a TV show without using catchup URLs.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "$ref": "#/components/parameters/ago"
          },
          {
            "name": "thumbnails",
            "in": "query",
            "description": "If specified, the thumbnail playlist is added to the primary playlist.\n\nExample of the thumbnail playlist:\n\n```\n <AdaptationSet id=\"3\" mimeType=\"image/jpeg\" contentType=\"image\">\n         <SegmentTemplate media=\"$RepresentationID$/dvr-1648098000-$Time$.m4v.jpg\" duration=\"72\"></SegmentTemplate>\n         <Representation bandwidth=\"10000\" id=\"images-320x240\" width=\"320\" height=\"240\">\n            <EssentialProperty schemeIdUri=\"http://dashif.org/guidelines/thumbnail_tile\" value=\"1x1\"/>\n         </Representation>\n  </AdaptationSet>\n```\n\nThis value defines how many thumbnail links will be added  \nto the thumbnail playlist to cover requested duration of the DVR window.  \nThe player adds the thumbnail links to the progress bar  \nat regular intervals. The interval duration between thumbnails  \nis calculated by dividing the total duration of the DVR window  \nby this value.\n\n**Note**: This option requires the following parameters  \nto be included in the stream settings:\n\n- `thumbnails enabled=ondemand`\n- `size`\n\nFor example, `thumbnails enabled=ondemand size=320x240;`.\n",
            "schema": {
              "type": "integer",
              "example": 100
            },
            "required": false
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/dash+xml": {
                "schema": {
                  "type": "string"
                }
              }
            },
            "description": "DASH rewind manifest"
          }
        },
        "tags": [
          "dash"
        ]
      }
    },
    "/{name}/archive-{from}-{duration}.mpd": {
      "get": {
        "operationId": "dash_dvr_manifest",
        "summary": "DASH DVR",
        "description": "If your stream is already recorded on the server with DVR, you can use this URL to play a specified DVR window, for example,\nyou can play a telecast if you know its beginning and end from EPG.\n\nThis URL works in two modes: file and event. If `duration` is specified as `now`, this\nurl will respond with a growing playlist for playing an event.\n\nIf `duration` is an exact positive number, then the server will respond with playlist, having\nthis requested amount of seconds of video as a file.\n\nNote the following rules:\n\n  * The first segment in this playlist will not start earlier than `from`.\n  * The last segment in this playlist will not start later than `from + duration`.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "$ref": "#/components/parameters/from"
          },
          {
            "$ref": "#/components/parameters/duration"
          },
          {
            "name": "period",
            "in": "query",
            "description": "Flussonic can create DASH manifest of two types: with multiple periods  \nand with a single period.\n\nBy default, Flussonic creates a multi-period manifest.  \nIf there's a break in playing a stream (such as a stream restart)  \nor a change in video quality, Flussonic starts a new playback period.  \nSo the resulting playlist consists of multiple continuous periods.\n\nSuch a manifest is incompatible with a wide range of devices and TV sets.  \nIn such cases you can specify the `period=mono` option:  \n`http://FLUSSONIC-IP/STREAMNAME/archive-TIME-DURATION.mpd?period=mono`.  \nAs a result, Flussonic recalculates timestamps of all frames  \nand merges the segments of the interrupted video into a single period.\n\n**Note**: This option should not work in the event mode  \nas Flussonic can't merge periods that occur in future.\n",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "mono"
              ]
            }
          },
          {
            "name": "thumbnails",
            "in": "query",
            "description": "If specified, the thumbnail playlist is added to the primary playlist.\n\nExample of the thumbnail playlist:\n\n```\n <AdaptationSet id=\"3\" mimeType=\"image/jpeg\" contentType=\"image\">\n         <SegmentTemplate media=\"$RepresentationID$/dvr-1648098000-$Time$.m4v.jpg\" duration=\"771\"></SegmentTemplate>\n         <Representation bandwidth=\"10000\" id=\"images-320x240\" width=\"320\" height=\"240\">\n            <EssentialProperty schemeIdUri=\"http://dashif.org/guidelines/thumbnail_tile\" value=\"1x1\"/>\n         </Representation>\n  </AdaptationSet>\n```\n\nThis value defines how many thumbnail links will be added  \nto the thumbnail playlist to cover the requested duration of the DVR window.  \nThe player adds the thumbnail links to the progress bar  \nat regular intervals. The interval duration between thumbnails is calculated  \nby dividing the total duration of the DVR window by this value.\n\n**Note**: This option requires the following parameters  \nto be included in the stream settings:\n\n- `thumbnails enabled=ondemand`\n- `size`\n\nFor example, `thumbnails enabled=ondemand size=320x240;`.\n",
            "schema": {
              "type": "integer",
              "example": 100
            },
            "required": false
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/dash+xml": {
                "schema": {
                  "type": "string"
                }
              }
            },
            "description": "DASH DVR manifest"
          }
        },
        "tags": [
          "dash",
          "dvr"
        ]
      }
    },
    "/{name}/timeshift_abs-{from}.mpd": {
      "get": {
        "operationId": "dash_timeshift_abs_manifest",
        "summary": "DASH absolute timeshift",
        "description": "If your stream is already recorded on the server with DVR, you can use this URL to play the recorded stream by DASH starting at a specified moment of time.\nFor example, you can use it for old STBs or viewing recoreded shows with EPG.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "$ref": "#/components/parameters/from"
          },
          {
            "name": "thumbnails",
            "in": "query",
            "description": "If specified, the thumbnail playlist is added to the primary playlist.\n\nExample of the thumbnail playlist:\n```\n <AdaptationSet id=\"3\" mimeType=\"image/jpeg\" contentType=\"image\">\n         <SegmentTemplate media=\"$RepresentationID$/dvr-1648098000-$Time$.m4v.jpg\" duration=\"775\"></SegmentTemplate>\n         <Representation bandwidth=\"10000\" id=\"images-320x240\" width=\"320\" height=\"240\">\n            <EssentialProperty schemeIdUri=\"http://dashif.org/guidelines/thumbnail_tile\" value=\"1x1\"/>\n         </Representation>\n  </AdaptationSet>\n```\n\nThis value defines how many thumbnail links will be added  \nto the thumbnail playlist to cover requested duration of the DVR window.  \nThe player adds the thumbnail links to the progress bar  \nat regular intervals. The interval duration between thumbnails  \nis calculated by dividing the total duration of the DVR window  \nby this value.\n\n**Note**: This option requires the following parameters  \nto be included in the stream settings:\n\n- `thumbnails enabled=ondemand`\n- `size`\n\nFor example, `thumbnails enabled=ondemand size=320x240;`.\n",
            "schema": {
              "type": "integer",
              "example": 100
            },
            "required": false
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/dash+xml": {
                "schema": {
                  "type": "string"
                }
              }
            },
            "description": "DASH DVR manifest with links to other manifests"
          }
        },
        "tags": [
          "dash",
          "dvr"
        ]
      }
    },
    "/{name}/whip": {
      "post": {
        "operationId": "webrtc_publish",
        "summary": "Publish WebRTC",
        "description": "Use this URL for publishing streams via WHIP (WebRTC HTTP ingestion protocol).\n\nNote that JSON schema is provided for information purposes only so that you could see which fields are checked. \nIt doesn't work for the start of WHIP session. Flussonic uses SDP only. \nPlease select **application/sdp** in **REQUEST BODY SCHEMA** to see example SDP content.\n\nThis API is for developing your WebRTC app that establishes the session itself. \nYou do not need it when using our [Flussonic WebRTC Player](https://www.npmjs.com/package/@flussonic/flussonic-webrtc-player)\nlibrary: it will prepare the URL and SDP for you.\n",
        "externalDocs": {
          "description": "Read more about WebRTC in our documentation.",
          "url": "https://flussonic.com/doc/publish-to-media-server-via-webrtc-with-whip/"
        },
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "name": "X-Sid",
            "in": "header",
            "required": true,
            "description": "Publisher session id",
            "schema": {
              "type": "string",
              "format": "uuid",
              "example": "8e03978e-40d5-43e8-bc93-6894a57f9324",
              "x-format-description": "uuid"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/webrtc_sdp"
              }
            },
            "application/sdp": {
              "schema": {
                "type": "string"
              },
              "example": "v=0\no=- 1900749552751431108 2 IN IP4 127.0.0.1\ns=-\nt=0 0\na=group:BUNDLE 0 1\na=extmap-allow-mixed\na=msid-semantic: WMS\nm=video 51690 UDP/TLS/RTP/SAVPF 96 97 98 99 100 101 102 121 127 120 125 107 108 109 124 119 123 117 35 36 114 115 116 62 118\nc=IN IP4 31.162.199.203\na=rtcp:9 IN IP4 0.0.0.0\na=candidate:2906905223 1 udp 2122260223 192.168.137.23 51690 typ host generation 0 network-id 1\na=candidate:2999745851 1 udp 2122194687 192.168.56.1 51691 typ host generation 0 network-id 2\na=candidate:3821020791 1 tcp 1518280447 192.168.137.23 9 typ host tcptype active generation 0 network-id 1\na=candidate:4233069003 1 tcp 1518214911 192.168.56.1 9 typ host tcptype active generation 0 network-id 2\na=candidate:1640949012 1 udp 1686052607 31.162.199.203 51690 typ srflx raddr 192.168.137.23 rport 51690 generation 0 network-id 1\na=ice-ufrag:Xe0E\na=ice-pwd:ZKMaqSu99xNCiT6K82qPwPf3\na=ice-options:trickle\na=fingerprint:sha-256 6A:98:9A:95:AA:88:65:27:10:70:A4:E6:DD:68:E6:95:44:DE:BA:35:DC:58:98:90:9B:28:85:FE:AD:CA:65:E5\na=setup:actpass\na=mid:0\na=extmap:1 urn:ietf:params:rtp-hdrext:toffset\na=extmap:2 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time\na=extmap:3 urn:3gpp:video-orientation\na=extmap:4 http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01\na=extmap:5 http://www.webrtc.org/experiments/rtp-hdrext/playout-delay\na=extmap:6 http://www.webrtc.org/experiments/rtp-hdrext/video-content-type\na=extmap:7 http://www.webrtc.org/experiments/rtp-hdrext/video-timing\na=extmap:8 http://www.webrtc.org/experiments/rtp-hdrext/color-space\na=extmap:9 urn:ietf:params:rtp-hdrext:sdes:mid\na=extmap:10 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id\na=extmap:11 urn:ietf:params:rtp-hdrext:sdes:repaired-rtp-stream-id\na=sendonly\na=msid:- ac9578b5-7cd2-482f-a3e6-9fa6f1e86708\na=rtcp-mux\na=rtcp-rsize\na=rtpmap:102 H264/90000\na=rtcp-fb:102 goog-remb\na=rtcp-fb:102 transport-cc\na=rtcp-fb:102 ccm fir\na=rtcp-fb:102 nack\na=rtcp-fb:102 nack pli\na=fmtp:102 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42001f\na=rtpmap:121 rtx/90000\na=fmtp:121 apt=102\na=rtpmap:127 H264/90000\na=rtcp-fb:127 goog-remb\na=rtcp-fb:127 transport-cc\na=rtcp-fb:127 ccm fir\na=rtcp-fb:127 nack\na=rtcp-fb:127 nack pli\na=fmtp:127 level-asymmetry-allowed=1;packetization-mode=0;profile-level-id=42001f\na=rtpmap:120 rtx/90000\na=fmtp:120 apt=127\na=rtpmap:125 H264/90000\na=rtcp-fb:125 goog-remb\na=rtcp-fb:125 transport-cc\na=rtcp-fb:125 ccm fir\na=rtcp-fb:125 nack\na=rtcp-fb:125 nack pli\na=fmtp:125 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f\na=rtpmap:107 rtx/90000\na=fmtp:107 apt=125\na=rtpmap:108 H264/90000\na=rtcp-fb:108 goog-remb\na=rtcp-fb:108 transport-cc\na=rtcp-fb:108 ccm fir\na=rtcp-fb:108 nack\na=rtcp-fb:108 nack pli\na=fmtp:108 level-asymmetry-allowed=1;packetization-mode=0;profile-level-id=42e01f\na=rtpmap:109 rtx/90000\na=fmtp:109 apt=108\na=rtpmap:124 H264/90000\na=rtcp-fb:124 goog-remb\na=rtcp-fb:124 transport-cc\na=rtcp-fb:124 ccm fir\na=rtcp-fb:124 nack\na=rtcp-fb:124 nack pli\na=fmtp:124 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=4d001f\na=rtpmap:119 rtx/90000\na=fmtp:119 apt=124\na=rtpmap:123 H264/90000\na=rtcp-fb:123 goog-remb\na=rtcp-fb:123 transport-cc\na=rtcp-fb:123 ccm fir\na=rtcp-fb:123 nack\na=rtcp-fb:123 nack pli\na=fmtp:123 level-asymmetry-allowed=1;packetization-mode=0;profile-level-id=4d001f\na=rtpmap:117 rtx/90000\na=fmtp:117 apt=123\na=rtpmap:35 AV1/90000\na=rtcp-fb:35 goog-remb\na=rtcp-fb:35 transport-cc\na=rtcp-fb:35 ccm fir\na=rtcp-fb:35 nack\na=rtcp-fb:35 nack pli\na=rtpmap:36 rtx/90000\na=fmtp:36 apt=35\na=rtpmap:114 H264/90000\na=rtcp-fb:114 goog-remb\na=rtcp-fb:114 transport-cc\na=rtcp-fb:114 ccm fir\na=rtcp-fb:114 nack\na=rtcp-fb:114 nack pli\na=fmtp:114 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=64001f\na=rtpmap:115 rtx/90000\na=fmtp:115 apt=114\na=rtpmap:116 red/90000\na=rtpmap:62 rtx/90000\na=fmtp:62 apt=116\na=rtpmap:118 ulpfec/90000\na=ssrc-group:FID 657786204 3295886568\na=ssrc:657786204 cname:YpNwHKOoRBP44CMP\na=ssrc:657786204 msid:- ac9578b5-7cd2-482f-a3e6-9fa6f1e86708\na=ssrc:657786204 mslabel:-\na=ssrc:657786204 label:ac9578b5-7cd2-482f-a3e6-9fa6f1e86708\na=ssrc:3295886568 cname:YpNwHKOoRBP44CMP\na=ssrc:3295886568 msid:- ac9578b5-7cd2-482f-a3e6-9fa6f1e86708\na=ssrc:3295886568 mslabel:-\na=ssrc:3295886568 label:ac9578b5-7cd2-482f-a3e6-9fa6f1e86708\nm=audio 51692 UDP/TLS/RTP/SAVPF 111 63 103 104 9 0 8 106 105 13 110 112 113 126\nc=IN IP4 31.162.199.203\na=rtcp:9 IN IP4 0.0.0.0\na=candidate:2906905223 1 udp 2122260223 192.168.137.23 51692 typ host generation 0 network-id 1\na=candidate:2999745851 1 udp 2122194687 192.168.56.1 51693 typ host generation 0 network-id 2\na=candidate:3821020791 1 tcp 1518280447 192.168.137.23 9 typ host tcptype active generation 0 network-id 1\na=candidate:4233069003 1 tcp 1518214911 192.168.56.1 9 typ host tcptype active generation 0 network-id 2\na=candidate:1640949012 1 udp 1686052607 31.162.199.203 51692 typ srflx raddr 192.168.137.23 rport 51692 generation 0 network-id 1\na=ice-ufrag:Xe0E\na=ice-pwd:ZKMaqSu99xNCiT6K82qPwPf3\na=ice-options:trickle\na=fingerprint:sha-256 6A:98:9A:95:AA:88:65:27:10:70:A4:E6:DD:68:E6:95:44:DE:BA:35:DC:58:98:90:9B:28:85:FE:AD:CA:65:E5\na=setup:actpass\na=mid:1\na=extmap:14 urn:ietf:params:rtp-hdrext:ssrc-audio-level\na=extmap:2 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time\na=extmap:4 http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01\na=extmap:9 urn:ietf:params:rtp-hdrext:sdes:mid\na=sendonly\na=msid:- 170865e1-1d18-429e-a930-aa4c00422f51\na=rtcp-mux\na=rtpmap:111 opus/48000/2\na=rtcp-fb:111 transport-cc\na=fmtp:111 minptime=10;useinbandfec=1\na=rtpmap:63 red/48000/2\na=fmtp:63 111/111\na=rtpmap:103 ISAC/16000\na=rtpmap:104 ISAC/32000\na=rtpmap:9 G722/8000\na=rtpmap:0 PCMU/8000\na=rtpmap:8 PCMA/8000\na=rtpmap:106 CN/32000\na=rtpmap:105 CN/16000\na=rtpmap:13 CN/8000\na=rtpmap:110 telephone-event/48000\na=rtpmap:112 telephone-event/32000\na=rtpmap:113 telephone-event/16000\na=rtpmap:126 telephone-event/8000\na=ssrc:3100432724 cname:YpNwHKOoRBP44CMP\na=ssrc:3100432724 msid:- 170865e1-1d18-429e-a930-aa4c00422f51\na=ssrc:3100432724 mslabel:-\na=ssrc:3100432724 label:170865e1-1d18-429e-a930-aa4c00422f51\n"
            }
          }
        },
        "responses": {
          "201": {
            "description": "Start publishing via WebRTC\n",
            "headers": {
              "Location": {
                "schema": {
                  "type": "string",
                  "format": "url",
                  "x-format-description": "url"
                },
                "description": "`http://server/{name}/whip/{session_id}`\n\nLocation of this publish session\n"
              },
              "X-Sid": {
                "schema": {
                  "type": "string",
                  "format": "uuid",
                  "x-format-description": "uuid"
                },
                "description": "Publish session id\n"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/webrtc_sdp"
                }
              },
              "application/sdp": {
                "schema": {
                  "type": "string"
                },
                "example": "v=0\no=- 2543206157126501998 2 IN IP4 127.0.0.1\ns=-\nt=0 0\na=group:BUNDLE 0 1\na=extmap-allow-mixed\na=ice-lite\nm=video 9 UDP/TLS/RTP/SAVPF 114\nc=IN IP4 0.0.0.0\na=rtcp:9 IN IP4 0.0.0.0\na=candidate:1 1 udp 2130706431 192.168.137.39 51085 typ host\na=ice-ufrag:CLjm\na=ice-pwd:3WpJtFeMv4RKdeItGDE+Hn\na=ice-options:trickle\na=fingerprint:sha-256 5B:5D:A9:CE:C7:6D:99:E6:FB:C9:4C:CA:82:E1:04:6B:AD:E0:D8:27:52:B4:A5:2D:01:D7:C9:2D:AC:31:56:1B\na=setup:active\na=mid:0\na=recvonly\na=rtcp-mux\na=rtpmap:114 H264/90000\na=rtcp-fb:114 ccm fir\na=rtcp-fb:114 nack\na=rtcp-fb:114 nack pli\na=rtcp-fb:114 goog-remb\na=rtcp-fb:114 transport-cc\na=fmtp:114 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=64001f\nm=audio 9 UDP/TLS/RTP/SAVPF 111\nc=IN IP4 0.0.0.0\na=rtcp:9 IN IP4 0.0.0.0\na=candidate:1 1 udp 2130706431 192.168.137.39 51085 typ host\na=ice-ufrag:CLjm\na=ice-pwd:3WpJtFeMv4RKdeItGDE+Hn\na=ice-options:trickle\na=fingerprint:sha-256 5B:5D:A9:CE:C7:6D:99:E6:FB:C9:4C:CA:82:E1:04:6B:AD:E0:D8:27:52:B4:A5:2D:01:D7:C9:2D:AC:31:56:1B\na=setup:active\na=mid:1\na=recvonly\na=rtcp-mux\na=rtpmap:111 opus/48000/2\na=rtcp-fb:111 transport-cc\na=fmtp:111 minptime=10;useinbandfec=1\n"
              }
            }
          },
          "400": {
            "description": "Invalid request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          },
          "403": {
            "description": "Unauthorized error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          },
          "404": {
            "description": "Media not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "tags": [
          "webrtc"
        ]
      }
    },
    "/{name}/whep": {
      "post": {
        "operationId": "webrtc_play",
        "summary": "Play WebRTC",
        "description": "Use this URL for playing streams via WHEP (WebRTC-HTTP egress protocol).\n\nNote that JSON schema is provided for information purposes only so that you could see which fields are checked. \nIt doesn't work for the start of WHEP session. Flussonic uses SDP only. \nPlease select **application/sdp** in **REQUEST BODY SCHEMA** to see example SDP content.\n\nThis API is for developing your WebRTC app that establishes the session itself. \nYou do not need it when using our [Flussonic WebRTC Player](https://www.npmjs.com/package/@flussonic/flussonic-webrtc-player)\nlibrary: it will prepare the URL and SDP for you.\n",
        "externalDocs": {
          "description": "Read more about WebRTC in our documentation.",
          "url": "https://flussonic.com/doc/play-webrtc-play-page/"
        },
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "name": "start_track",
            "in": "query",
            "description": "If a stream has several video tracks, use this parameter to specify from which track playback should be started.\n",
            "required": false,
            "schema": {
              "type": "string",
              "example": "v1"
            }
          },
          {
            "name": "filter.tracks",
            "in": "query",
            "description": "If a stream has several audio and video tracks, use this parameter to specify which tracks should be delivered.\n",
            "required": false,
            "schema": {
              "type": "string",
              "example": "v1a1"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/webrtc_sdp"
              }
            },
            "application/sdp": {
              "schema": {
                "type": "string"
              },
              "example": "v=0\no=- 4727635898622679868 2 IN IP4 127.0.0.1\ns=-\nt=0 0\na=group:BUNDLE 0 1\na=extmap-allow-mixed\na=msid-semantic: WMS\nm=video 52338 UDP/TLS/RTP/SAVPF 96 97 98 99 100 101 102 121 127 120 125 107 108 109 124 119 123 117 35 36 114 115 116 62 118\nc=IN IP4 31.162.199.203\na=rtcp:9 IN IP4 0.0.0.0\na=candidate:2906905223 1 udp 2122260223 192.168.137.23 52338 typ host generation 0 network-id 1\na=candidate:2999745851 1 udp 2122194687 192.168.56.1 52339 typ host generation 0 network-id 2\na=candidate:3821020791 1 tcp 1518280447 192.168.137.23 9 typ host tcptype active generation 0 network-id 1\na=candidate:4233069003 1 tcp 1518214911 192.168.56.1 9 typ host tcptype active generation 0 network-id 2\na=candidate:1640949012 1 udp 1686052607 31.162.199.203 52338 typ srflx raddr 192.168.137.23 rport 52338 generation 0 network-id 1\na=ice-ufrag:K5HU\na=ice-pwd:bwKzfjlZh9DMnqynGfD11wiJ\na=ice-options:trickle\na=fingerprint:sha-256 B2:51:E3:3E:83:DF:95:11:BA:D7:04:9B:F3:B6:19:B3:04:80:8F:A6:A5:68:62:29:C7:1B:5C:A1:58:C0:E8:04\na=setup:actpass\na=mid:0\na=extmap:1 urn:ietf:params:rtp-hdrext:toffset\na=extmap:2 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time\na=extmap:3 urn:3gpp:video-orientation\na=extmap:4 http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01\na=extmap:5 http://www.webrtc.org/experiments/rtp-hdrext/playout-delay\na=extmap:6 http://www.webrtc.org/experiments/rtp-hdrext/video-content-type\na=extmap:7 http://www.webrtc.org/experiments/rtp-hdrext/video-timing\na=extmap:8 http://www.webrtc.org/experiments/rtp-hdrext/color-space\na=extmap:9 urn:ietf:params:rtp-hdrext:sdes:mid\na=extmap:10 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id\na=extmap:11 urn:ietf:params:rtp-hdrext:sdes:repaired-rtp-stream-id\na=sendrecv\na=msid:- 18d32ec8-dddb-4585-8f35-738a2a9d2f21\na=rtcp-mux\na=rtcp-rsize\na=rtpmap:102 H264/90000\na=rtcp-fb:102 goog-remb\na=rtcp-fb:102 transport-cc\na=rtcp-fb:102 ccm fir\na=rtcp-fb:102 nack\na=rtcp-fb:102 nack pli\na=fmtp:102 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42001f\na=rtpmap:121 rtx/90000\na=fmtp:121 apt=102\na=rtpmap:127 H264/90000\na=rtcp-fb:127 goog-remb\na=rtcp-fb:127 transport-cc\na=rtcp-fb:127 ccm fir\na=rtcp-fb:127 nack\na=rtcp-fb:127 nack pli\na=fmtp:127 level-asymmetry-allowed=1;packetization-mode=0;profile-level-id=42001f\na=rtpmap:120 rtx/90000\na=fmtp:120 apt=127\na=rtpmap:125 H264/90000\na=rtcp-fb:125 goog-remb\na=rtcp-fb:125 transport-cc\na=rtcp-fb:125 ccm fir\na=rtcp-fb:125 nack\na=rtcp-fb:125 nack pli\na=fmtp:125 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f\na=rtpmap:107 rtx/90000\na=fmtp:107 apt=125\na=rtpmap:108 H264/90000\na=rtcp-fb:108 goog-remb\na=rtcp-fb:108 transport-cc\na=rtcp-fb:108 ccm fir\na=rtcp-fb:108 nack\na=rtcp-fb:108 nack pli\na=fmtp:108 level-asymmetry-allowed=1;packetization-mode=0;profile-level-id=42e01f\na=rtpmap:109 rtx/90000\na=fmtp:109 apt=108\na=rtpmap:124 H264/90000\na=rtcp-fb:124 goog-remb\na=rtcp-fb:124 transport-cc\na=rtcp-fb:124 ccm fir\na=rtcp-fb:124 nack\na=rtcp-fb:124 nack pli\na=fmtp:124 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=4d001f\na=rtpmap:119 rtx/90000\na=fmtp:119 apt=124\na=rtpmap:123 H264/90000\na=rtcp-fb:123 goog-remb\na=rtcp-fb:123 transport-cc\na=rtcp-fb:123 ccm fir\na=rtcp-fb:123 nack\na=rtcp-fb:123 nack pli\na=fmtp:123 level-asymmetry-allowed=1;packetization-mode=0;profile-level-id=4d001f\na=rtpmap:117 rtx/90000\na=fmtp:117 apt=123\na=rtpmap:35 AV1/90000\na=rtcp-fb:35 goog-remb\na=rtcp-fb:35 transport-cc\na=rtcp-fb:35 ccm fir\na=rtcp-fb:35 nack\na=rtcp-fb:35 nack pli\na=rtpmap:36 rtx/90000\na=fmtp:36 apt=35\na=rtpmap:114 H264/90000\na=rtcp-fb:114 goog-remb\na=rtcp-fb:114 transport-cc\na=rtcp-fb:114 ccm fir\na=rtcp-fb:114 nack\na=rtcp-fb:114 nack pli\na=fmtp:114 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=64001f\na=rtpmap:115 rtx/90000\na=fmtp:115 apt=114\na=rtpmap:116 red/90000\na=rtpmap:62 rtx/90000\na=fmtp:62 apt=116\na=rtpmap:118 ulpfec/90000\na=ssrc-group:FID 2222738982 2341899489\na=ssrc:2222738982 cname:FtBZk8aw7pqc+hDM\na=ssrc:2222738982 msid:- 18d32ec8-dddb-4585-8f35-738a2a9d2f21\na=ssrc:2222738982 mslabel:-\na=ssrc:2222738982 label:18d32ec8-dddb-4585-8f35-738a2a9d2f21\na=ssrc:2341899489 cname:FtBZk8aw7pqc+hDM\na=ssrc:2341899489 msid:- 18d32ec8-dddb-4585-8f35-738a2a9d2f21\na=ssrc:2341899489 mslabel:-\na=ssrc:2341899489 label:18d32ec8-dddb-4585-8f35-738a2a9d2f21\nm=audio 52340 UDP/TLS/RTP/SAVPF 111 63 103 104 9 0 8 106 105 13 110 112 113 126\nc=IN IP4 31.162.199.203\na=rtcp:9 IN IP4 0.0.0.0\na=candidate:2906905223 1 udp 2122260223 192.168.137.23 52340 typ host generation 0 network-id 1\na=candidate:2999745851 1 udp 2122194687 192.168.56.1 52341 typ host generation 0 network-id 2\na=candidate:3821020791 1 tcp 1518280447 192.168.137.23 9 typ host tcptype active generation 0 network-id 1\na=candidate:4233069003 1 tcp 1518214911 192.168.56.1 9 typ host tcptype active generation 0 network-id 2\na=candidate:1640949012 1 udp 1686052607 31.162.199.203 52340 typ srflx raddr 192.168.137.23 rport 52340 generation 0 network-id 1\na=ice-ufrag:K5HU\na=ice-pwd:bwKzfjlZh9DMnqynGfD11wiJ\na=ice-options:trickle\na=fingerprint:sha-256 B2:51:E3:3E:83:DF:95:11:BA:D7:04:9B:F3:B6:19:B3:04:80:8F:A6:A5:68:62:29:C7:1B:5C:A1:58:C0:E8:04\na=setup:actpass\na=mid:1\na=extmap:14 urn:ietf:params:rtp-hdrext:ssrc-audio-level\na=extmap:2 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time\na=extmap:4 http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01\na=extmap:9 urn:ietf:params:rtp-hdrext:sdes:mid\na=sendrecv\na=msid:- 284b6644-5590-4755-a27c-cfd9af9fe07b\na=rtcp-mux\na=rtpmap:111 opus/48000/2\na=rtcp-fb:111 transport-cc\na=fmtp:111 minptime=10;useinbandfec=1\na=rtpmap:63 red/48000/2\na=fmtp:63 111/111\na=rtpmap:103 ISAC/16000\na=rtpmap:104 ISAC/32000\na=rtpmap:9 G722/8000\na=rtpmap:0 PCMU/8000\na=rtpmap:8 PCMA/8000\na=rtpmap:106 CN/32000\na=rtpmap:105 CN/16000\na=rtpmap:13 CN/8000\na=rtpmap:110 telephone-event/48000\na=rtpmap:112 telephone-event/32000\na=rtpmap:113 telephone-event/16000\na=rtpmap:126 telephone-event/8000\na=ssrc:3768357041 cname:FtBZk8aw7pqc+hDM\na=ssrc:3768357041 msid:- 284b6644-5590-4755-a27c-cfd9af9fe07b\na=ssrc:3768357041 mslabel:-\na=ssrc:3768357041 label:284b6644-5590-4755-a27c-cfd9af9fe07b\n"
            }
          }
        },
        "responses": {
          "201": {
            "description": "Start playing via WebRTC\n",
            "headers": {
              "Location": {
                "schema": {
                  "type": "string",
                  "format": "url",
                  "x-format-description": "url"
                },
                "description": "`http://server/{name}/whep/{session_id}`\n\nLocation of this play session\n"
              },
              "X-Sid": {
                "schema": {
                  "type": "string",
                  "format": "uuid",
                  "x-format-description": "uuid"
                },
                "description": "Play session id\n"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/webrtc_sdp"
                }
              },
              "application/sdp": {
                "schema": {
                  "type": "string",
                  "example": "v=0\no=- 3346066250962052830 2 IN IP4 127.0.0.1\ns=-\nt=0 0\na=group:BUNDLE 0 1\na=extmap-allow-mixed\na=ice-lite\nm=video 9 UDP/TLS/RTP/SAVPF 102\nc=IN IP4 0.0.0.0\na=rtcp:9 IN IP4 0.0.0.0\na=candidate:1 1 udp 2130706431 192.168.137.39 37090 typ host\na=ice-ufrag:Phpx\na=ice-pwd:cCnT564WpS1DdOFl3QGfWM\na=ice-options:trickle\na=fingerprint:sha-256 FA:7B:C2:0B:BF:CB:78:A8:32:7A:05:38:25:2B:47:4D:AB:B4:BF:96:9F:F3:08:E3:9F:F9:44:AB:CE:2D:F6:EB\na=setup:active\na=mid:0\na=sendonly\na=rtcp-mux\na=rtpmap:102 H264/90000\na=rtcp-fb:102 ccm fir\na=rtcp-fb:102 nack\na=rtcp-fb:102 nack pli\na=rtcp-fb:102 goog-remb\na=rtcp-fb:102 transport-cc\na=fmtp:102 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42001f\na=ssrc:16680529 cname:g2gHZAAKd2VicnRj\nm=audio 9 UDP/TLS/RTP/SAVPF 111\nc=IN IP4 0.0.0.0\na=rtcp:9 IN IP4 0.0.0.0\na=candidate:1 1 udp 2130706431 192.168.137.39 37090 typ host\na=ice-ufrag:Phpx\na=ice-pwd:cCnT564WpS1DdOFl3QGfWM\na=ice-options:trickle\na=fingerprint:sha-256 FA:7B:C2:0B:BF:CB:78:A8:32:7A:05:38:25:2B:47:4D:AB:B4:BF:96:9F:F3:08:E3:9F:F9:44:AB:CE:2D:F6:EB\na=setup:active\na=mid:1\na=sendonly\na=rtcp-mux\na=rtpmap:111 opus/48000/2\na=rtcp-fb:111 transport-cc\na=fmtp:111 minptime=10;useinbandfec=1\na=ssrc:3193630825 cname:g2gHZAAKd2VicnRj\n"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          },
          "404": {
            "description": "Media not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "tags": [
          "webrtc"
        ]
      }
    },
    "/{name}/mpegts": {
      "get": {
        "operationId": "http_mpegts_live_play",
        "summary": "HTTP-MPEGTS playback",
        "description": "Use this URL to play a stream via HTTP-MPEGTS protocol.",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "video/mpeg": {
                "schema": {
                  "type": "string"
                }
              }
            },
            "description": "Played HTTP-MPEGTS chunked transfer encoding live stream"
          }
        },
        "tags": [
          "mpegts"
        ]
      },
      "post": {
        "operationId": "http_mpegts_live_publish",
        "summary": "HTTP-MPEGTS publishing",
        "description": "Use this URL to publish an HTTP MPEG-TS stream.",
        "externalDocs": {
          "description": "Find more information here",
          "url": "https://flussonic.com/doc/publish-video-on-media-server/#live-publish-mpegts"
        },
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          }
        ],
        "requestBody": {
          "content": {
            "video/mpeg": {
              "schema": {
                "type": "string"
              }
            }
          },
          "description": "Published HTTP-MPEGTS chunked transfer live stream."
        },
        "responses": {
          "204": {
            "description": "Void status that is really not used\n"
          }
        },
        "tags": [
          "mpegts"
        ]
      }
    },
    "/{name}/timeshift_abs-{from}.ts": {
      "get": {
        "operationId": "http_mpegts_timeshift_abs",
        "summary": "HTTP-MPEGTS absolute timeshift",
        "description": "If your stream is being recorded on the server with DVR, you can use this URL to play the recorded stream by HTTP-MPEGTS starting at a specified moment of time. \nFor example, you can use it for old STBs or viewing recoreded shows with EPG.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "$ref": "#/components/parameters/from"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "video/mpeg": {
                "schema": {
                  "type": "string"
                }
              }
            },
            "description": "HTTP-MPEGTS chunked transfer encoding live stream"
          }
        },
        "tags": [
          "mpegts",
          "dvr"
        ]
      }
    },
    "/{name}/timeshift_rel-{delay}.ts": {
      "get": {
        "operationId": "http_mpegts_timeshift_rel",
        "summary": "HTTP-MPEGTS relative timeshift",
        "description": "If your stream is being recorded on the server with DVR, you can use this URL to play the recorded stream by HTTP-MPEGTS with a specified delay. \nThis can be useful, for example, for TV broadcasting in different time zones, so that people in a different time zone watch morning broadcasts in the morning, and not late at night.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "$ref": "#/components/parameters/delay"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "video/mpeg": {
                "schema": {
                  "type": "string"
                }
              }
            },
            "description": "HTTP-MPEGTS chunked transfer encoding live stream"
          }
        },
        "tags": [
          "mpegts",
          "dvr"
        ]
      }
    },
    "/{name}/shoutcast": {
      "get": {
        "operationId": "shoutcast_live",
        "summary": "SHOUTcast playlist",
        "description": "Use this URL to play audio streams via SHOUTcast protocol which is used for streaming audio over an HTTP connection.",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "audio/mpeg": {
                "schema": {
                  "type": "string"
                }
              }
            },
            "description": "SHOUTcast stream"
          }
        },
        "tags": [
          "radio"
        ]
      }
    },
    "/{name}.isml/manifest": {
      "get": {
        "operationId": "mss_live_manifest",
        "summary": "MSS",
        "description": "Use this URL to play a stream via MSS (Microsoft Smooth Streaming) protocol.",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "name": "filter.tracks",
            "in": "query",
            "description": "If a stream has several audio, video, and subtitles tracks, use this parameter to specify which tracks should be delivered. \nFor example, `http://FLUSSONIC-IP/STREAMNAME.isml/manifest?filter.tracks=a1` - select audio only.\n\nSelecting tracks is useful to play video on client devices that do not support the multi-language MSS manifest.\n",
            "required": false,
            "schema": {
              "type": "string",
              "example": "v1a1"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "text/xml": {
                "schema": {
                  "type": "string"
                }
              }
            },
            "description": "MSS live"
          }
        },
        "tags": [
          "mss"
        ]
      }
    },
    "/{name}(archive={from}-{duration}).isml/manifest": {
      "get": {
        "operationId": "mss_dvr_manifest",
        "summary": "MSS DVR",
        "description": "If your stream is already recorded on the server with DVR, you can use this URL to play a specified DVR window, for example,\nyou can play a telecast if you know its beginning and end from EPG.\n\nThis URL works in two modes: file and event. If `duration` is specified as `now`, this\nurl will respond with a growing playlist for playing an event.\n\nIf `duration` is an exact positive number, then the server will respond with playlist, having\nthis requested amount of seconds of video as a file.\n\nNote the following rules:\n\n  * The first segment in this playlist will not start earlier than `from`.\n  * The last segment in this playlist will not start later than `from + duration`.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "$ref": "#/components/parameters/from"
          },
          {
            "$ref": "#/components/parameters/duration"
          },
          {
            "$ref": "#/components/parameters/chunk"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "text/xml": {
                "schema": {
                  "type": "string"
                }
              }
            },
            "description": "MSS DVR playlist"
          }
        },
        "tags": [
          "mss",
          "dvr"
        ]
      }
    },
    "/{name}/archive-{from}-{duration}.mp4": {
      "get": {
        "operationId": "mp4_export",
        "summary": "Export MP4",
        "description": "This URL is a recommended way to export a fragment of a DVR archive to a local computer as an MP4 file.",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "name": "from",
            "in": "path",
            "description": "The start time of the DVR window in UTC seconds.",
            "required": true,
            "schema": {
              "type": "integer",
              "example": 1641045644
            }
          },
          {
            "name": "duration",
            "in": "path",
            "description": "The duration of the DVR window in seconds. You also can specify `now` for a DVR window till current time.",
            "required": true,
            "schema": {
              "oneOf": [
                {
                  "type": "integer",
                  "format": "seconds",
                  "example": 7200,
                  "x-format-description": "seconds"
                },
                {
                  "type": "string",
                  "enum": [
                    "now"
                  ]
                }
              ]
            }
          },
          {
            "name": "filter.tracks",
            "in": "query",
            "description": "If a stream has several audio and video tracks, use this parameter to specify which tracks should be exported\n",
            "required": false,
            "schema": {
              "type": "string",
              "example": "v1a1"
            }
          },
          {
            "name": "packing",
            "in": "query",
            "description": "How to pack a recording data in the exported file",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "type": "string",
                  "const": "fragmented",
                  "description": "Make a fragmented MP4. This allows a download to start with a minimal delay. The resulting file may be not playable by some old players."
                },
                {
                  "type": "string",
                  "const": "compat",
                  "description": "Construct a traditional MP4 file.\nThis may require a significant time to start (especially with large `duration`)\nbut the resulting file is compatible with all players.\n"
                }
              ],
              "default": "fragmented",
              "example": "compat"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "video/mp4": {
                "schema": {
                  "type": "string"
                }
              }
            },
            "description": "MP4 file containing DVR content"
          }
        },
        "tags": [
          "mp4",
          "dvr"
        ]
      }
    },
    "/{name}/archive-{from}-{duration}.ts": {
      "get": {
        "operationId": "ts_export",
        "summary": "Export TS",
        "description": "This URL is a recommended way to export a fragment of a DVR archive to a local computer as an MPEG-TS file.",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "$ref": "#/components/parameters/from"
          },
          {
            "$ref": "#/components/parameters/duration"
          },
          {
            "name": "filter.tracks",
            "in": "query",
            "description": "If a stream has several audio and video tracks, use this parameter to specify which tracks should be exported\n",
            "required": false,
            "schema": {
              "type": "string",
              "example": "v1a1"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "video/mpeg": {
                "schema": {
                  "type": "string"
                }
              }
            },
            "description": "TS file containing DVR content"
          }
        },
        "tags": [
          "mpegts",
          "dvr"
        ]
      }
    },
    "/{name}/save-mp4-{from}-{duration}.mp4": {
      "get": {
        "operationId": "mp4_save",
        "summary": "Save MP4 to a server's storage",
        "description": "Legacy URL. See `dvr_export_job_start` in admin API for a better option.",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "name": "from",
            "in": "path",
            "description": "The start time of the DVR window in UTC seconds.",
            "required": true,
            "schema": {
              "type": "integer",
              "example": 1641045644
            }
          },
          {
            "name": "duration",
            "in": "path",
            "description": "The duration of the DVR window in seconds. You also can specify `now` for a DVR window till current time.",
            "required": true,
            "schema": {
              "oneOf": [
                {
                  "type": "integer",
                  "format": "seconds",
                  "example": 7200,
                  "x-format-description": "seconds"
                },
                {
                  "type": "string",
                  "enum": [
                    "now"
                  ]
                }
              ]
            }
          },
          {
            "name": "timelapse",
            "in": "query",
            "description": "Request a timelapse instead of normal speed",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "timelapse_kbps",
            "in": "query",
            "description": "Custom bitrate for timelapse",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "packing",
            "in": "query",
            "description": "How to pack a recording data in the exported file",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "type": "string",
                  "const": "fragmented",
                  "description": "Make a fragmented MP4. This allows a download to start with a minimal delay. The resulting file may be not playable by some old players."
                },
                {
                  "type": "string",
                  "const": "compat",
                  "description": "Construct a traditional MP4 file.\nThis may require a significant time to start (especially with large `duration`)\nbut the resulting file is compatible with all players.\n"
                }
              ],
              "default": "fragmented",
              "example": "compat"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            },
            "description": "The requested fragment has been successfully exported"
          },
          "303": {
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            },
            "description": "Export is taking long time, and the client is advised to monitor the job at other URI"
          }
        },
        "tags": [
          "mp4",
          "dvr"
        ]
      }
    },
    "/{name}/preview.jpg": {
      "get": {
        "operationId": "jpeg_preview",
        "summary": "JPEG thumbnail",
        "description": "If you configure JPEG thumbnail generation for a stream, \nthis URL can be used to access the stream's last thumbnail (keyframe) as a JPEG image.\n\nNote that generating JPEG thumbnails is a resource-intensive operation \nbecause Flussonic takes the first keyframe of each segment, decodes it to raw video, and encodes back to a JPEG image. \nPlease consider using MP4 video thumbnails instead.\n",
        "externalDocs": {
          "description": "Find more information here",
          "url": "https://flussonic.com/doc/thumbnails/"
        },
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "image/jpeg": {
                "schema": {
                  "type": "string",
                  "format": "binary",
                  "x-format-description": "binary"
                }
              }
            },
            "description": "Last keyframe as a JPEG file"
          }
        },
        "tags": [
          "image"
        ]
      }
    },
    "/{name}/{from}.jpg": {
      "get": {
        "operationId": "jpeg_preview_dvr",
        "summary": "JPEG thumbnail from DVR",
        "description": "If you configure JPEG thumbnail generation and DVR for a stream, \nthis URL can be used to access the stream's recorded thumbnail (keyframe) which is the closest to the specified time as a JPEG image.\n\nIf no thumbnails are recorded then `404 Not Found` will be returned.\n\nNote that generating JPEG thumbnails is a resource-intensive operation \nbecause Flussonic takes the first keyframe of each segment, decodes it to raw video, and encodes back to a JPEG image. \nPlease consider using MP4 video thumbnails instead.\n",
        "externalDocs": {
          "description": "Find more information here",
          "url": "https://flussonic.com/doc/thumbnails/"
        },
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "name": "from",
            "in": "path",
            "description": "The UTC moment after which Flussonic will search for the recorded JPEG.",
            "required": true,
            "schema": {
              "type": "string",
              "example": 1644216248
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "image/jpeg": {
                "schema": {
                  "type": "string",
                  "format": "binary",
                  "x-format-description": "binary"
                }
              }
            },
            "description": "Recorded JPEG file closest to the requested UTC moment.",
            "headers": {
              "X-Thumbnail-Utc": {
                "schema": {
                  "type": "integer",
                  "format": "utc",
                  "x-format-description": "Unix timestamp in seconds",
                  "minimum": 1000000000,
                  "maximum": 10000000000
                },
                "description": "Preview is created from keyframe. This header will tell exact UTC of this nearest keyframe.\n",
                "example": 1644216244
              }
            }
          },
          "404": {
            "description": "No recorded JPEG was found at requested UTC.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "tags": [
          "image"
        ]
      }
    },
    "/{name}/{from}-preview.jpg": {
      "get": {
        "operationId": "jpeg_preview_ondemand",
        "summary": "JPEG thumbnail from DVR or on-demand",
        "description": "This URL works in two modes depending on the stream settings:\n\n* If you configure JPEG thumbnail generation and DVR for a stream, \nthis URL can be used to access the stream's recorded thumbnail (keyframe) which is the closest to the specified time as a JPEG image.\n* If no thumbnails are recorded and `thumbnail` parameter is configured as `ondemand` then JPEG image will be\ngenerated from closest keyframe on the fly. \n\nNote that generating JPEG thumbnails is a resource-intensive operation \nbecause Flussonic takes the first keyframe of each segment, decodes it to raw video, and encodes back to a JPEG image. \nPlease consider using MP4 video thumbnails instead.\n",
        "externalDocs": {
          "description": "Find more information here",
          "url": "https://flussonic.com/doc/thumbnails/"
        },
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "name": "from",
            "in": "path",
            "description": "The UTC moment after which Flussonic will search for the recorded JPEG or the first keyframe to generate a JPEG file from.",
            "required": true,
            "schema": {
              "type": "string",
              "example": 1644216248
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "image/jpeg": {
                "schema": {
                  "type": "string"
                }
              }
            },
            "description": "Recorded or generated JPEG file closest to the requested UTC moment.",
            "headers": {
              "X-Thumbnail-Utc": {
                "schema": {
                  "type": "integer",
                  "format": "utc",
                  "x-format-description": "Unix timestamp in seconds",
                  "minimum": 1000000000,
                  "maximum": 10000000000
                },
                "description": "Preview is created from keyframe. This header will tell exact UTC of this nearest keyframe.\n",
                "example": 1644216244
              }
            }
          },
          "403": {
            "description": "No recorded JPEG was found and no permission was configured to generate JPEG from keyframe.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          },
          "404": {
            "description": "No recorded JPEG or keyframes were found at requested UTC.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "tags": [
          "image"
        ]
      }
    },
    "/{name}/snapshot-{pts}-{size}.jpg": {
      "get": {
        "operationId": "jpeg_snapshot",
        "summary": "Precisely extract a frame from DVR as JPEG image",
        "description": "This operation returns a JPEG made of specific video frame.\nSpecify a PTS (as millisecond timestamp).\nStreamer will decode the corresponding media segment from DVR,\nfind a video frame with PTS **nearest** to specified one and encode it as JPEG image.\nDesigned for running external video analytics\nor for use with external sensors, where output is just a timestamp.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "name": "pts",
            "in": "path",
            "description": "PTS (presentation timestamp) of a frame to extract and return.\nStreamer will find a frame with **nearest** PTS, so some deviation\nis allowed, and middleware is expected to round the original timestamp\nto an integer value\n",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "utc_ms",
              "example": 1732200271444,
              "x-format-description": "Unix timestamp in milliseconds",
              "minimum": 1000000000000,
              "maximum": 10000000000000
            }
          },
          {
            "name": "size",
            "in": "path",
            "description": "Desired snapshot resolution\nIn different cases user may need snapshots of different quality,\ne.g. it may be just 128x128 for a dense grid, 1280x720 for player splash,\nor a full original video size for including in reports.\nThis parameter tells the server snapshot of which size the client needs\n",
            "required": true,
            "schema": {
              "type": "string",
              "pattern": "full|[0-9]+x[0-9]+",
              "examples": {
                "full": {
                  "value": "full"
                },
                "thumbnail": {
                  "value": "128x128"
                },
                "splash": {
                  "value": "1280x720"
                }
              }
            }
          },
          {
            "name": "sign",
            "in": "query",
            "description": "Generating jpeg snapshots is a resource-intensive task.\nTo prevent DoS attacks by users, each request has to be signed by middleware\nto have control over resource consumption.\nThis parameter contains a token from the middleware to ensure\nthis request for JPEG generation is approved.\nFormat is <valid_till>_<Sha256Hash>\nvalid_till is UNIX time (seconds) when this token expires.\n```\nSha256Hash = sha256(str(valid_till) + \":\" + jpeg_snapshot_sign_key + \"@\" + name + \"/\" + \"snapshot-\" + str(pts) + \"-\" + size + \".jpg\")\n```\njpeg_snapshot_sign_key is a part of stream configuration\nFor example, when valid_till=1732200743, jpeg_snapshot_sign_key=\"TopSecret\", name=\"test\", pts=1732200271444, size=\"320x240\"\nsign would be 1732200743_176b3f0349c59f2d4561c8d1f82be90416cc8144b0ef0598856c4cf0d34d4dd8\n",
            "required": true,
            "schema": {
              "type": "string",
              "pattern": "[0-9]{10}_[0-9a-f]{64}",
              "examples": {
                "test_1732200271444": {
                  "valid_till": 1732200743,
                  "jpeg_snapshot_sign_key": "TopSecret",
                  "name": "test",
                  "pts": 1732200271444,
                  "size": "320x240",
                  "string_to_hash": "1732200743:TopSecret@test/snapshot-1732200271444-320x240.jpg",
                  "sha256sum": "176b3f0349c59f2d4561c8d1f82be90416cc8144b0ef0598856c4cf0d34d4dd8",
                  "value": "1732200743_176b3f0349c59f2d4561c8d1f82be90416cc8144b0ef0598856c4cf0d34d4dd8"
                },
                "demo_1732799815458": {
                  "valid_till": 1732800115,
                  "jpeg_snapshot_sign_key": "OtherSecret",
                  "name": "demo",
                  "pts": 1732799815458,
                  "size": "full",
                  "string_to_hash": "1732800115:OtherSecret@demo/snapshot-1732799815458-full.jpg",
                  "sha256sum": "52a0a25d2c09d2384332a1c081be23394c1faf17a223da4b56c7f6b77504a1b4",
                  "value": "1732800115_52a0a25d2c09d2384332a1c081be23394c1faf17a223da4b56c7f6b77504a1b4"
                }
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "JPEG representation of the frame with PTS nearest to requested one",
            "content": {
              "image/jpeg": {
                "schema": {
                  "type": "string"
                }
              }
            },
            "headers": {
              "X-Snapshot-Pts": {
                "schema": {
                  "type": "number",
                  "format": "utc_ms",
                  "x-format-description": "Unix timestamp in milliseconds",
                  "minimum": 1000000000000,
                  "maximum": 10000000000000
                },
                "description": "PTS of the frame which was a source to a generated JPEG\n",
                "example": 1732200271437.235
              }
            }
          }
        },
        "tags": [
          "image"
        ]
      }
    },
    "/{name}/preview.mp4": {
      "get": {
        "operationId": "mp4_preview",
        "summary": "MP4 thumbnail",
        "description": "Use this URL to get the last video thumbnail (keyframe) of a stream or a VOD file in MP4 format.\n\nVideo thumbnails are essentially fragments of H.264 video each containing one frame.\nFlussonic takes the first keyframe from each segment of a stream or a VOD file and creates an MP4 file from it. \nThis file is sent to the browser, where it is then shown as a picture.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "video/mp4": {
                "schema": {
                  "type": "string",
                  "format": "binary",
                  "x-format-description": "binary"
                }
              }
            },
            "description": "The last video thumbnail as an MP4 file"
          }
        },
        "tags": [
          "image"
        ]
      }
    },
    "/{name}/{from}-preview.mp4": {
      "get": {
        "operationId": "mp4_dvr",
        "summary": "MP4 DVR thumbnail",
        "description": "If your stream is already being recorded on the server with DVR, \nyou can use this URL to get a video thumbnail in MP4 format as the first keyframe after a specified moment of time.\n",
        "externalDocs": {
          "description": "Find more information here",
          "url": "https://flussonic.com/doc/video-thumbnails/#thumbnails-video-dvr-video-thumbnails"
        },
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "name": "from",
            "in": "path",
            "description": "The UTC moment after which Flussonic will search for the first keyframe to generate MP4 file from.\n\nIf you know that somewhere in 10 minutes after a point in time you have recorded video, you can request unexistent URL (with approximate time).\nFlussonic will find the existing keyframe in that period of time and return it. \nThis approach will save your cache: the browser will make two requests, but only the existing keyframe will be saved to the browser cache.\n",
            "required": true,
            "schema": {
              "type": "integer",
              "example": 1641045644
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "video/mp4": {
                "schema": {
                  "type": "string"
                }
              }
            },
            "description": "The first keyframe after the specified moment as an MP4 file"
          }
        },
        "tags": [
          "image"
        ]
      }
    },
    "/{name}/preview-{from}.mp4": {
      "get": {
        "operationId": "mp4_vod",
        "summary": "MP4 VOD thumbnail",
        "description": "In case of video file placed in VOD storage you can use this URL to get a video thumbnail in MP4 format\nas the first keyframe after a specified moment of time.\n",
        "externalDocs": {
          "description": "Find more information here",
          "url": "https://flussonic.com/doc/video-thumbnails/#thumbnails-video-vod"
        },
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "name": "from",
            "in": "path",
            "description": "The moment after which Flussonic will search for the first keyframe to generate MP4 file from.\n\nThe time is specified in the format: `hh-mm-ss` relatively to beginning of the file.\n",
            "required": true,
            "schema": {
              "type": "string",
              "example": "01-23-55"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "video/mp4": {
                "schema": {
                  "type": "string"
                }
              }
            },
            "description": "The first keyframe after the specified moment as an MP4 file"
          }
        },
        "tags": [
          "image"
        ]
      }
    },
    "/{name}/logo": {
      "get": {
        "operationId": "media_logo",
        "summary": "Media logo",
        "description": "This URL returns the logo image in PNG format, configured for a stream.",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "image/png": {
                "schema": {
                  "type": "string",
                  "format": "binary",
                  "x-format-description": "binary"
                }
              }
            },
            "description": "Logo image in PNG format"
          }
        },
        "tags": [
          "image"
        ]
      }
    },
    "/{name}/embed.html": {
      "get": {
        "operationId": "embed_html",
        "summary": "Embed HTML",
        "description": "Use this URL to play a stream or a VOD file in a special `embed.html` player provided by Flussonic Media Server. It allows to play video in a browser or to insert video into a website. This player is supported by any client device (browser, smartphone).",
        "externalDocs": {
          "description": "Find more information here",
          "url": "https://flussonic.com/doc/insert-video-embed-on-website/"
        },
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "name": "dvr",
            "in": "query",
            "description": "Opens the DVR player for a stream with DVR enabled.\n",
            "schema": {
              "type": "boolean",
              "example": true,
              "default": false
            },
            "required": false
          },
          {
            "name": "realtime",
            "in": "query",
            "description": "Enables broadcasts via low latency protocols. Automatically selects from MSE-LD or WebRTC.\n",
            "schema": {
              "type": "boolean",
              "example": true,
              "default": false
            },
            "required": false
          },
          {
            "name": "autoplay",
            "in": "query",
            "description": "Autostarts playing video once the page is opened. Displays screenshots before viewing. \nSound availability is defined by the browser policy.\n",
            "schema": {
              "type": "boolean",
              "example": false,
              "default": true
            },
            "required": false
          },
          {
            "name": "mute",
            "in": "query",
            "description": "Mute the sound.",
            "schema": {
              "type": "boolean",
              "example": true
            },
            "required": false
          },
          {
            "name": "localtime",
            "in": "query",
            "description": "The option controls timezone in the player's UI. \n\nWhen the option is set to `true`, the timeline shows time in local timezone of your browser.\n\nWhen set to `false`, the timeline shows time in UTC+0 timezone. \nThis way may be useful, for example, when your cameras are installed in different timezones \nand you need a unified reference to view the archive.\n",
            "schema": {
              "type": "boolean",
              "default": true,
              "example": false
            }
          },
          {
            "name": "export_limit",
            "in": "query",
            "description": "The option controls user timeline selection and limits his possibility of selection large export ranges.\n",
            "schema": {
              "type": "integer",
              "format": "seconds",
              "default": 86400,
              "example": 3600,
              "x-format-description": "seconds"
            }
          },
          {
            "name": "volume",
            "in": "query",
            "description": "Initial player sound volume level on a scale from 0 to 100.",
            "schema": {
              "type": "integer",
              "example": 50
            },
            "required": false
          },
          {
            "name": "play_duration",
            "in": "query",
            "description": "The number of seconds until video playback stops. Useful for saving traffic.\n",
            "schema": {
              "type": "integer",
              "format": "seconds",
              "example": 3600,
              "x-format-description": "seconds"
            },
            "required": false
          },
          {
            "name": "ago",
            "in": "query",
            "description": "Allows users to rewind back. The value is specified in seconds. \nIt's more convenient than DVR player for viewing video in the last few minutes or hours. \nIdeal for pausing and rewinding live video on the site. \n",
            "schema": {
              "type": "integer",
              "format": "seconds",
              "example": 3600,
              "x-format-description": "seconds"
            },
            "required": false
          },
          {
            "name": "from",
            "in": "query",
            "description": "The Unix timestamp from where to start playing. \nIf this option is specified, the player will play the playlist with absolute timeshift starting from the specified time.\n",
            "schema": {
              "type": "integer",
              "format": "utc",
              "example": 1641045644,
              "x-format-description": "Unix timestamp in seconds",
              "minimum": 1000000000,
              "maximum": 10000000000
            },
            "required": false
          },
          {
            "name": "to",
            "in": "query",
            "description": "The Unix timestamp where to end playing. \nUsed only together with `from`. \nThe player will open HLS VOD, and rewinding will be available within the specified time interval.\n",
            "schema": {
              "type": "integer",
              "format": "utc",
              "example": 1641045852,
              "x-format-description": "Unix timestamp in seconds",
              "minimum": 1000000000,
              "maximum": 10000000000
            },
            "required": false
          }
        ],
        "responses": {
          "200": {
            "content": {
              "text/html": {
                "schema": {
                  "type": "string"
                }
              }
            },
            "description": "HTML with player"
          }
        },
        "tags": [
          "player"
        ]
      }
    },
    "/{name}/recording_status.json": {
      "get": {
        "operationId": "recording_status",
        "summary": "Get recording status",
        "deprecated": true,
        "x-delete-at": 25.04,
        "description": "Use this method to get the information about DVR recording status of a stream.\nThe method is replaced with `ranges_list`\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/dvr_info"
                }
              }
            },
            "description": "Recording info"
          }
        },
        "tags": [
          "api"
        ]
      }
    },
    "/{name}/ranges.json": {
      "get": {
        "operationId": "ranges_list",
        "summary": "Get DVR ranges",
        "description": "Use this method to get the DVR ranges for a particular stream.\n\nDVR ranges are the valid parts of the archive.\n\nThe method is used to get a detailed archive map. Usage examples:\n\n  * draw recordings on the timeline of a player\n  * get parts that should to be replicated.\n\nDVR range is a time interval without any gaps.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          },
          {
            "name": "closed_at_gte",
            "in": "query",
            "description": "Will not send ranges that have `closed_at_gte` earlier this `closed_at_gte`.\n\nThis is an analog of `from`, left border of screen.\n",
            "schema": {
              "type": "integer",
              "format": "utc_ms",
              "example": 1641045644000,
              "x-format-description": "Unix timestamp in milliseconds",
              "minimum": 1000000000000,
              "maximum": 10000000000000
            }
          },
          {
            "name": "opened_at_lte",
            "in": "query",
            "description": "Will not send ranges that have `opened_at` time later this `opened_at_lte`.\n\nThis is an analog of `to`, right border of screen.\n",
            "schema": {
              "type": "integer",
              "format": "utc_ms",
              "example": 1646045644000,
              "x-format-description": "Unix timestamp in milliseconds",
              "minimum": 1000000000000,
              "maximum": 10000000000000
            }
          },
          {
            "name": "resolution",
            "in": "query",
            "description": "This parameter is sent by player to reduce response size.\n\n`resolution` is an amount of seconds that can fit into one pixel on screen.\nServer will collapse and merge all ranges that have gap between them less than `resolution`.\n\nFor example if you show timeline on a screen with 500 pixels width and it is 2 days of recording,\n`resolution = 2*86400 / 500 = 345`\n\nIt means that all gaps between ranges smalle than 6 minutes, will disappear, because\nit is impossible to draw them. \n",
            "schema": {
              "type": "integer",
              "example": 350
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/stream_dvr_ranges_list"
                }
              }
            },
            "description": "DVR ranges"
          }
        },
        "tags": [
          "api"
        ]
      }
    },
    "/{name}/media_info.json": {
      "get": {
        "operationId": "media_info",
        "summary": "Get media info",
        "deprecated": true,
        "x-delete-at": 25.04,
        "description": "Use this method to get technical information about the output media content.\nThis method is applicable for a live stream or a VOD file.\n\nThe method is replaced with `public_stream_get`. Media info is a part of\nstream stats.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/media_info"
                }
              }
            },
            "description": "Media info"
          }
        },
        "tags": [
          "api"
        ]
      }
    },
    "/{name}/info.json": {
      "get": {
        "operationId": "public_stream_get",
        "summary": "Get one stream",
        "description": "This method allows you to fetch stream metadata.\nThe data returned in this method are the same as for `streams_list` operation.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/name"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/public_stream_config"
                }
              }
            },
            "description": "Stream metadata"
          }
        },
        "tags": [
          "api"
        ]
      }
    },
    "/tv/playlists/{name}": {
      "parameters": [
        {
          "name": "name",
          "in": "path",
          "required": true,
          "description": "the name of the user which is subscribed to receive some stream package",
          "schema": {
            "example": "client01",
            "type": "string"
          },
          "style": "simple"
        }
      ],
      "get": {
        "operationId": "playlist_get",
        "summary": "Get m3u playlist",
        "description": "Get m3u playlist for existing user which is subscribed to receive some stream package",
        "responses": {
          "200": {
            "description": "Media playlist file",
            "content": {
              "application/x-mpegurl": {
                "schema": {
                  "type": "string",
                  "format": "binary",
                  "x-format-description": "binary"
                }
              }
            },
            "headers": {
              "Content-Disposition": {
                "schema": {
                  "type": "string",
                  "description": "Media playlist file",
                  "example": "attachment; filename=\"client01.m3u\""
                }
              }
            }
          }
        },
        "tags": [
          "iptv"
        ]
      }
    },
    "/-/streams": {
      "get": {
        "operationId": "streams_list",
        "summary": "List streams",
        "description": "This API can return list of streams.\n",
        "parameters": [
          {
            "name": "sort",
            "description": "Composite sort direction.\nDefault sort order is `named_by (config,user,remote)`, `position`, `name`.\n",
            "explode": false,
            "in": "query",
            "required": false,
            "schema": {
              "example": "-stats.bitrate,name,position",
              "type": "string"
            },
            "style": "form"
          },
          {
            "name": "limit",
            "description": "Limit select count in collection to N elements.  Default value is 100.",
            "explode": false,
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "example": 100
            },
            "style": "form"
          },
          {
            "name": "cursor",
            "description": "Properly encoded analog of offset, allowing to read next bunch of items. \nWe do not offer common `offset` fields, use please cursor for predictable\nfetching of quickly changing list of items. Learn more in [Flussonic API design principles](https://flussonic.com/doc/rest-api-guidelines/#api-http-collections-cursor).\n",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "example": "JTI0cG9zaXRpb25fZ3Q9MQ=="
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/public_streams_list"
                }
              }
            },
            "description": "Response"
          }
        },
        "tags": [
          "streams"
        ]
      }
    }
  },
  "security": [
    {
      "tokenAuth": []
    }
  ],
  "servers": [
    {
      "description": "your local installation",
      "url": "http://localhost:8080"
    }
  ],
  "tags": [
    {
      "name": "hls",
      "description": "HLS playback."
    },
    {
      "name": "hls-ts",
      "description": "HLS TS playback."
    },
    {
      "name": "hls-fmp4",
      "description": "HLS FMP4 playback"
    },
    {
      "name": "dash",
      "description": "DASH playback"
    },
    {
      "name": "ll-hls",
      "description": "Apple Low-Latency HLS playback"
    },
    {
      "name": "webrtc",
      "description": "Playing and publishing video via WebRTC"
    },
    {
      "name": "radio",
      "description": "Playing audio streams"
    },
    {
      "name": "mpegts",
      "description": "Playing and publishing HTTP MPEG-TS video"
    },
    {
      "name": "mss",
      "description": "Playing MSS video"
    },
    {
      "name": "image",
      "description": "Managing images during playback"
    },
    {
      "name": "api",
      "description": "Getting information about played video"
    },
    {
      "name": "player",
      "description": "Playing video in `embed.html` player in a browser or on a website."
    },
    {
      "name": "mp4",
      "description": "Getting content in MP4 video container."
    },
    {
      "name": "iptv"
    },
    {
      "name": "streams"
    },
    {
      "name": "dvr",
      "description": "Methods that could be used to play recorded data."
    }
  ]
}